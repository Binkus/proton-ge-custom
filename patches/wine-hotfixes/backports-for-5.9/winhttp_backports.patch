From a294f755ceaeeb07bdf08e1cb445cbcd542fa533 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Mon, 25 May 2020 22:36:24 -0600
Subject: [PATCH] ws2_32: Reimplement inet_ntop on top of ntdll functions.

And add a couple of tests for IPv6 addresses that Windows represents
using dot-decimal notation for the last 32 bits but GNU/Linux does not.

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 configure                |  3 ---
 configure.ac             |  3 ---
 dlls/ws2_32/socket.c     | 20 ++++++--------------
 dlls/ws2_32/tests/sock.c |  6 ++++++
 include/config.h.in      |  9 ---------
 5 files changed, 12 insertions(+), 29 deletions(-)

diff --git a/configure b/configure
index e2e03dc4ba7..a5516fe60eb 100755
--- a/configure
+++ b/configure
@@ -18296,9 +18296,6 @@ for ac_func in \
 	getprotobyname \
 	getprotobynumber \
 	getservbyport \
-	inet_addr \
-	inet_network \
-	inet_ntop \
 
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
diff --git a/configure.ac b/configure.ac
index d81f5cc88ca..b43ec739294 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2249,9 +2249,6 @@ AC_CHECK_FUNCS(\
 	getprotobyname \
 	getprotobynumber \
 	getservbyport \
-	inet_addr \
-	inet_network \
-	inet_ntop \
 )
 
 dnl Check for clock_gettime which may be in -lrt
diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index bdfe63ee191..199b7187a87 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -8351,10 +8351,8 @@ int WINAPI WSARemoveServiceClass(LPGUID info)
  */
 PCSTR WINAPI WS_inet_ntop( INT family, PVOID addr, PSTR buffer, SIZE_T len )
 {
-#ifdef HAVE_INET_NTOP
-    struct WS_in6_addr *in6;
-    struct WS_in_addr  *in;
-    PCSTR pdst;
+    NTSTATUS status;
+    ULONG size = min( len, (ULONG)-1 );
 
     TRACE("family %d, addr (%p), buffer (%p), len %ld\n", family, addr, buffer, len);
     if (!buffer)
@@ -8367,14 +8365,12 @@ PCSTR WINAPI WS_inet_ntop( INT family, PVOID addr, PSTR buffer, SIZE_T len )
     {
     case WS_AF_INET:
     {
-        in = addr;
-        pdst = inet_ntop( AF_INET, &in->WS_s_addr, buffer, len );
+        status = RtlIpv4AddressToStringExA( (IN_ADDR *)addr, 0, buffer, &size );
         break;
     }
     case WS_AF_INET6:
     {
-        in6 = addr;
-        pdst = inet_ntop( AF_INET6, in6->WS_s6_addr, buffer, len );
+        status = RtlIpv6AddressToStringExA( (IN6_ADDR *)addr, 0, 0, buffer, &size );
         break;
     }
     default:
@@ -8382,13 +8378,9 @@ PCSTR WINAPI WS_inet_ntop( INT family, PVOID addr, PSTR buffer, SIZE_T len )
         return NULL;
     }
 
-    if (!pdst) SetLastError( STATUS_INVALID_PARAMETER );
-    return pdst;
-#else
-    FIXME( "not supported on this platform\n" );
-    SetLastError( WSAEAFNOSUPPORT );
+    if (status == STATUS_SUCCESS) return buffer;
+    SetLastError( STATUS_INVALID_PARAMETER );
     return NULL;
-#endif
 }
 
 /***********************************************************************
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index c72dc7a77a1..cd9a13937ca 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -5008,6 +5008,12 @@ static void test_inet_pton(void)
         "0x12345678", NULL, NULL},
         {AF_INET6, 0, 0, /* windows bug */
         "::1:2:3:4:5:6:7", NULL, NULL},
+        {AF_INET6, 1, 0,              /* Test 30 */
+        "::5efe:1.2.3.4", "::5efe:1.2.3.4",
+        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x5e\xfe\x01\x02\x03\x04"},
+        {AF_INET6, 1, 0,
+        "::ffff:0:1.2.3.4", "::ffff:0:1.2.3.4",
+        "\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff\x00\x00\x01\x02\x03\x04"},
     };
     int i, ret;
     DWORD err;
diff --git a/include/config.h.in b/include/config.h.in
index d2933eee65a..26424873129 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -296,18 +296,9 @@
 /* Define to 1 if you have the `ilogbf' function. */
 #undef HAVE_ILOGBF
 
-/* Define to 1 if you have the `inet_addr' function. */
-#undef HAVE_INET_ADDR
-
 /* Define to 1 if you have the <inet/mib2.h> header file. */
 #undef HAVE_INET_MIB2_H
 
-/* Define to 1 if you have the `inet_network' function. */
-#undef HAVE_INET_NETWORK
-
-/* Define to 1 if you have the `inet_ntop' function. */
-#undef HAVE_INET_NTOP
-
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
From 73ef942c6537b9faaf6401387b91d408e972beb8 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Tue, 26 May 2020 23:33:32 -0600
Subject: [PATCH] ws2_32/tests: Put WSAAddressToString tests in tables.

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/tests/sock.c | 431 +++++++++++----------------------------
 1 file changed, 115 insertions(+), 316 deletions(-)

diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index cd9a13937ca..d9ceca98cc6 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -3082,334 +3082,136 @@ static void test_WSAEnumNetworkEvents(void)
     }
 }
 
-static void test_WSAAddressToStringA(void)
+static void test_WSAAddressToString(void)
 {
-    SOCKET v6 = INVALID_SOCKET;
-    INT ret;
-    DWORD len;
-    int GLE;
+    static struct
+    {
+        ULONG address;
+        USHORT port;
+        char output[32];
+    }
+    ipv4_tests[] =
+    {
+        { 0, 0, "0.0.0.0" },
+        { 0xffffffff, 0, "255.255.255.255" },
+        { 0, 0xffff, "0.0.0.0:65535" },
+        { 0xffffffff, 0xffff, "255.255.255.255:65535" },
+    };
+    static struct
+    {
+        USHORT address[8];
+        ULONG scope;
+        USHORT port;
+        char output[64];
+    }
+    ipv6_tests[] =
+    {
+        { { 0, 0, 0, 0, 0, 0, 0, 0x100 }, 0, 0, "::1" },
+        { { 0xab20, 0, 0, 0, 0, 0, 0, 0x100 }, 0, 0, "20ab::1" },
+        { { 0xab20, 0, 0, 0, 0, 0, 0, 0x120 }, 0, 0xfa81, "[20ab::2001]:33274" },
+        { { 0xab20, 0, 0, 0, 0, 0, 0, 0x120 }, 0x1234, 0xfa81, "[20ab::2001%4660]:33274" },
+        { { 0xab20, 0, 0, 0, 0, 0, 0, 0x120 }, 0x1234, 0, "20ab::2001%4660" },
+    };
     SOCKADDR_IN sockaddr;
-    CHAR address[22]; /* 12 digits + 3 dots + ':' + 5 digits + '\0' */
-
-    CHAR expect1[] = "0.0.0.0";
-    CHAR expect2[] = "255.255.255.255";
-    CHAR expect3[] = "0.0.0.0:65535";
-    CHAR expect4[] = "255.255.255.255:65535";
-
     SOCKADDR_IN6 sockaddr6;
-    CHAR address6[54]; /* 32 digits + 7':' + '[' + '%" + 5 digits + ']:' + 5 digits + '\0' */
-
-    CHAR addr6_1[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};
-    CHAR addr6_2[] = {0x20,0xab,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};
-    CHAR addr6_3[] = {0x20,0xab,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01};
-
-    CHAR expect6_1[] = "::1";
-    CHAR expect6_2[] = "20ab::1";
-    CHAR expect6_3[] = "[20ab::2001]:33274";
-    CHAR expect6_3_2[] = "[20ab::2001%4660]:33274";
-    CHAR expect6_3_3[] = "20ab::2001%4660";
-
-    len = 0;
-
-    sockaddr.sin_family = AF_INET;
-    sockaddr.sin_port = 0;
-    sockaddr.sin_addr.s_addr = 0;
-
-    ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, address, &len );
-    GLE = WSAGetLastError();
-    ok( (ret == SOCKET_ERROR && GLE == WSAEFAULT) || (ret == 0), 
-        "WSAAddressToStringA() failed unexpectedly: WSAGetLastError()=%d, ret=%d\n",
-        GLE, ret );
-
-    len = sizeof(address);
-
-    sockaddr.sin_family = AF_INET;
-    sockaddr.sin_port = 0;
-    sockaddr.sin_addr.s_addr = 0;
-
-    ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, address, &len );
-    ok( !ret, "WSAAddressToStringA() failed unexpectedly: %d\n", WSAGetLastError() );
-
-    ok( !strcmp( address, expect1 ), "Expected: %s, got: %s\n", expect1, address );
-    ok( len == sizeof( expect1 ), "Got size %d\n", len);
-
-    len = sizeof(address);
-
-    sockaddr.sin_family = AF_INET;
-    sockaddr.sin_port = 0;
-    sockaddr.sin_addr.s_addr = 0xffffffff;
-
-    ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, address, &len );
-    ok( !ret, "WSAAddressToStringA() failed unexpectedly: %d\n", WSAGetLastError() );
-
-    ok( !strcmp( address, expect2 ), "Expected: %s, got: %s\n", expect2, address );
-
-    len = sizeof(address);
-
-    sockaddr.sin_family = AF_INET;
-    sockaddr.sin_port = 0xffff;
-    sockaddr.sin_addr.s_addr = 0;
-
-    ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, address, &len );
-    ok( !ret, "WSAAddressToStringA() failed unexpectedly: %d\n", WSAGetLastError() );
-
-    ok( !strcmp( address, expect3 ), "Expected: %s, got: %s\n", expect3, address );
-
-    len = sizeof(address);
-
-    sockaddr.sin_family = AF_INET;
-    sockaddr.sin_port = 0xffff;
-    sockaddr.sin_addr.s_addr = 0xffffffff;
-
-    ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, address, &len );
-    ok( !ret, "WSAAddressToStringA() failed unexpectedly: %d\n", WSAGetLastError() );
-
-    ok( !strcmp( address, expect4 ), "Expected: %s, got: %s\n", expect4, address );
-    ok( len == sizeof( expect4 ), "Got size %d\n", len);
-
-    /*check to see it IPv6 is available */
-    v6 = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
-    if (v6 == INVALID_SOCKET) {
-        skip("Could not create IPv6 socket (LastError: %d; %d expected if IPv6 not available).\n",
-            WSAGetLastError(), WSAEAFNOSUPPORT);
-        goto end;
-    }
-    /* Test a short IPv6 address */
-    len = sizeof(address6);
-
-    sockaddr6.sin6_family = AF_INET6;
-    sockaddr6.sin6_port = 0x0000;
-    sockaddr6.sin6_scope_id = 0;
-    memcpy (sockaddr6.sin6_addr.s6_addr, addr6_1, sizeof(addr6_1));
-
-    ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, address6, &len );
-    ok( !ret, "WSAAddressToStringA() failed unexpectedly: %d\n", WSAGetLastError() );
-    ok( !strcmp( address6, expect6_1 ), "Expected: %s, got: %s\n", expect6_1, address6 );
-    ok( len == sizeof(expect6_1), "Got size %d\n", len);
-
-    /* Test a longer IPv6 address */
-    len = sizeof(address6);
-
-    sockaddr6.sin6_family = AF_INET6;
-    sockaddr6.sin6_port = 0x0000;
-    sockaddr6.sin6_scope_id = 0;
-    memcpy (sockaddr6.sin6_addr.s6_addr, addr6_2, sizeof(addr6_2));
-
-    ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, address6, &len );
-    ok( !ret, "WSAAddressToStringA() failed unexpectedly: %d\n", WSAGetLastError() );
-    ok( !strcmp( address6, expect6_2 ), "Expected: %s, got: %s\n", expect6_2, address6 );
-    ok( len == sizeof(expect6_2), "Got size %d\n", len);
-
-    /* Test IPv6 address and port number */
-    len = sizeof(address6);
-
-    sockaddr6.sin6_family = AF_INET6;
-    sockaddr6.sin6_port = 0xfa81;
-    sockaddr6.sin6_scope_id = 0;
-    memcpy (sockaddr6.sin6_addr.s6_addr, addr6_3, sizeof(addr6_3));
-
-    ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, address6, &len );
-    ok( !ret, "WSAAddressToStringA() failed unexpectedly: %d\n", WSAGetLastError() );
-    ok( !strcmp( address6, expect6_3 ), "Expected: %s, got: %s\n", expect6_3, address6 );
-    ok( len == sizeof(expect6_3), "Got size %d\n", len );
-
-    /* Test IPv6 address, port number and scope_id */
-    len = sizeof(address6);
-
-    sockaddr6.sin6_family = AF_INET6;
-    sockaddr6.sin6_port = 0xfa81;
-    sockaddr6.sin6_scope_id = 0x1234;
-    memcpy (sockaddr6.sin6_addr.s6_addr, addr6_3, sizeof(addr6_3));
-
-    ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, address6, &len );
-    ok( !ret, "WSAAddressToStringA() failed unexpectedly: %d\n", WSAGetLastError() );
-    ok( !strcmp( address6, expect6_3_2 ), "Expected: %s, got: %s\n", expect6_3_2, address6 );
-    ok( len == sizeof(expect6_3_2), "Got size %d\n", len );
-
-    /* Test IPv6 address and scope_id */
-    len = sizeof(address6);
-
-    sockaddr6.sin6_family = AF_INET6;
-    sockaddr6.sin6_port = 0x0000;
-    sockaddr6.sin6_scope_id = 0x1234;
-    memcpy (sockaddr6.sin6_addr.s6_addr, addr6_3, sizeof(addr6_3));
-
-    ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, address6, &len );
-    ok( !ret, "WSAAddressToStringA() failed unexpectedly: %d\n", WSAGetLastError() );
-    ok( !strcmp( address6, expect6_3_3 ), "Expected: %s, got: %s\n", expect6_3_3, address6 );
-    ok( len == sizeof(expect6_3_3), "Got size %d\n", len );
-
-end:
-    if (v6 != INVALID_SOCKET)
-        closesocket(v6);
-}
-
-static void test_WSAAddressToStringW(void)
-{
-    SOCKET v6 = INVALID_SOCKET;
+    char output[64];
+    WCHAR outputW[64], expected_outputW[64];
+    SOCKET v6;
     INT ret;
     DWORD len;
-    int GLE;
-    SOCKADDR_IN sockaddr;
-    WCHAR address[22]; /* 12 digits + 3 dots + ':' + 5 digits + '\0' */
-
-    WCHAR expect1[] = { '0','.','0','.','0','.','0', 0 };
-    WCHAR expect2[] = { '2','5','5','.','2','5','5','.','2','5','5','.','2','5','5', 0 };
-    WCHAR expect3[] = { '0','.','0','.','0','.','0', ':', '6', '5', '5', '3', '5', 0 };
-    WCHAR expect4[] = { '2','5','5','.','2','5','5','.','2','5','5','.','2','5','5', ':',
-                        '6', '5', '5', '3', '5', 0 };
-
-    SOCKADDR_IN6 sockaddr6;
-    WCHAR address6[54]; /* 32 digits + 7':' + '[' + '%" + 5 digits + ']:' + 5 digits + '\0' */
-
-    CHAR addr6_1[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};
-    CHAR addr6_2[] = {0x20,0xab,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01};
-    CHAR addr6_3[] = {0x20,0xab,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01};
-
-    WCHAR expect6_1[] = {':',':','1',0};
-    WCHAR expect6_2[] = {'2','0','a','b',':',':','1',0};
-    WCHAR expect6_3[] = {'[','2','0','a','b',':',':','2','0','0','1',']',':','3','3','2','7','4',0};
-    WCHAR expect6_3_2[] = {'[','2','0','a','b',':',':','2','0','0','1','%','4','6','6','0',']',':','3','3','2','7','4',0};
-    WCHAR expect6_3_3[] = {'2','0','a','b',':',':','2','0','0','1','%','6','5','5','3','4',0};
+    int i, j;
 
     len = 0;
-
     sockaddr.sin_family = AF_INET;
-    sockaddr.sin_port = 0;
     sockaddr.sin_addr.s_addr = 0;
-
-    ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, address, &len );
-    GLE = WSAGetLastError();
-    ok( (ret == SOCKET_ERROR && GLE == WSAEFAULT) || (ret == 0), 
-        "WSAAddressToStringW() failed unexpectedly: WSAGetLastError()=%d, ret=%d\n",
-        GLE, ret );
-
-    len = sizeof(address);
-
-    sockaddr.sin_family = AF_INET;
     sockaddr.sin_port = 0;
-    sockaddr.sin_addr.s_addr = 0;
+    ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, output, &len );
+    ok( ret == SOCKET_ERROR, "WSAAddressToStringA() returned %d, expected SOCKET_ERROR\n", ret );
+    ok( WSAGetLastError() == WSAEFAULT, "WSAAddressToStringA() gave error %d, expected WSAEFAULT\n", WSAGetLastError() );
+    ok( len == 8, "WSAAddressToStringA() gave length %d, expected 8\n", len );
 
-    ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, address, &len );
-    ok( !ret, "WSAAddressToStringW() failed unexpectedly: %d\n", WSAGetLastError() );
-
-    ok( !lstrcmpW( address, expect1 ), "Expected different address string\n" );
-    ok( len == ARRAY_SIZE(expect1), "Got size %d\n", len);
-
-    len = sizeof(address);
-
-    sockaddr.sin_family = AF_INET;
-    sockaddr.sin_port = 0;
-    sockaddr.sin_addr.s_addr = 0xffffffff;
-
-    ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, address, &len );
-    ok( !ret, "WSAAddressToStringW() failed unexpectedly: %d\n", WSAGetLastError() );
-
-    ok( !lstrcmpW( address, expect2 ), "Expected different address string\n" );
-
-    len = sizeof(address);
-
-    sockaddr.sin_family = AF_INET;
-    sockaddr.sin_port = 0xffff;
-    sockaddr.sin_addr.s_addr = 0;
-
-    ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, address, &len );
-    ok( !ret, "WSAAddressToStringW() failed unexpectedly: %d\n", WSAGetLastError() );
-
-    ok( !lstrcmpW( address, expect3 ), "Expected different address string\n" );
-
-    len = sizeof(address);
+    for (i = 0; i < 2; i++)
+    {
+        for (j = 0; j < ARRAY_SIZE(ipv4_tests); j++)
+        {
+            sockaddr.sin_family = AF_INET;
+            sockaddr.sin_addr.s_addr = ipv4_tests[j].address;
+            sockaddr.sin_port = ipv4_tests[j].port;
 
-    sockaddr.sin_family = AF_INET;
-    sockaddr.sin_port = 0xffff;
-    sockaddr.sin_addr.s_addr = 0xffffffff;
+            if (i == 0)
+            {
+                len = sizeof(output);
+                memset(output, 0, len);
+                ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, output, &len );
+                ok( !ret, "ipv4_tests[%d] failed unexpectedly: %d\n", j, WSAGetLastError() );
+                ok( lstrcmpA( output, ipv4_tests[j].output ) == 0,
+                    "ipv4_tests[%d]: got address %s, expected %s\n",
+                    j, wine_dbgstr_a(output), wine_dbgstr_a(ipv4_tests[j].output) );
+                ok( len == lstrlenA(ipv4_tests[j].output) + 1,
+                    "ipv4_tests[%d]: got length %d, expected %d\n",
+                    j, len, lstrlenA(ipv4_tests[j].output) + 1 );
+            }
+            else
+            {
+                len = sizeof(outputW);
+                memset(outputW, 0, len);
+                ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, outputW, &len );
+                MultiByteToWideChar( CP_ACP, 0, ipv4_tests[j].output, -1,
+                                     expected_outputW, ARRAY_SIZE(expected_outputW) );
+                ok( !ret, "ipv4_tests[%d] failed unexpectedly: %d\n", j, WSAGetLastError() );
+                ok( lstrcmpW( outputW, expected_outputW ) == 0,
+                    "ipv4_tests[%d]: got address %s, expected %s\n",
+                    j, wine_dbgstr_w(outputW), wine_dbgstr_w(expected_outputW) );
+                ok( len == lstrlenW(expected_outputW) + 1,
+                    "ipv4_tests[%d]: got length %d, expected %d\n",
+                    j, len, lstrlenW(expected_outputW) + 1 );
+            }
+        }
 
-    ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr, sizeof(sockaddr), NULL, address, &len );
-    ok( !ret, "WSAAddressToStringW() failed unexpectedly: %d\n", WSAGetLastError() );
+        /* check to see if IPv6 is available */
+        v6 = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
+        if (v6 == INVALID_SOCKET) {
+            skip("Could not create IPv6 socket (LastError: %d; %d expected if IPv6 not available).\n",
+                WSAGetLastError(), WSAEAFNOSUPPORT);
+            continue;
+        }
+        closesocket(v6);
 
-    ok( !lstrcmpW( address, expect4 ), "Expected different address string\n" );
-    ok( len == ARRAY_SIZE(expect4), "Got %d\n", len);
+        for (j = 0; j < ARRAY_SIZE(ipv6_tests); j++)
+        {
+            sockaddr6.sin6_family = AF_INET6;
+            sockaddr6.sin6_scope_id = ipv6_tests[j].scope;
+            sockaddr6.sin6_port = ipv6_tests[j].port;
+            memcpy( sockaddr6.sin6_addr.s6_addr, ipv6_tests[j].address, sizeof(ipv6_tests[j].address) );
 
-    /*check to see it IPv6 is available */
-    v6 = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
-    if (v6 == INVALID_SOCKET) {
-        skip("Could not create IPv6 socket (LastError: %d; %d expected if IPv6 not available).\n",
-            WSAGetLastError(), WSAEAFNOSUPPORT);
-        goto end;
+            if (i == 0)
+            {
+                len = sizeof(output);
+                ret = WSAAddressToStringA( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, output, &len );
+                ok( !ret, "ipv6_tests[%d] failed unexpectedly: %d\n", j, WSAGetLastError() );
+                ok( lstrcmpA( output, ipv6_tests[j].output ) == 0,
+                    "ipv6_tests[%d]: gave address %s, expected %s\n",
+                    j, wine_dbgstr_a(output), wine_dbgstr_a(ipv6_tests[j].output) );
+                ok( len == lstrlenA(ipv6_tests[j].output) + 1,
+                    "ipv6_tests[%d]: got length %d, expected %d\n",
+                    j, len, lstrlenA(ipv6_tests[j].output) + 1 );
+            }
+            else
+            {
+                len = sizeof(outputW);
+                ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, outputW, &len );
+                MultiByteToWideChar( CP_ACP, 0, ipv6_tests[j].output, -1,
+                                     expected_outputW, ARRAY_SIZE(expected_outputW) );
+                ok( !ret, "ipv6_tests[%d] failed unexpectedly: %d\n", j, WSAGetLastError() );
+                ok( lstrcmpW( outputW, expected_outputW ) == 0,
+                    "ipv6_tests[%d]: got address %s, expected %s\n",
+                    j, wine_dbgstr_w(outputW), wine_dbgstr_w(expected_outputW) );
+                ok( len == lstrlenW(expected_outputW) + 1,
+                    "ipv6_tests[%d]: got length %d, expected %d\n",
+                    j, len, lstrlenW(expected_outputW) + 1 );
+            }
+        }
     }
-
-    /* Test a short IPv6 address */
-    len = ARRAY_SIZE(address6);
-
-    sockaddr6.sin6_family = AF_INET6;
-    sockaddr6.sin6_port = 0x0000;
-    sockaddr6.sin6_scope_id = 0;
-    memcpy (sockaddr6.sin6_addr.s6_addr, addr6_1, sizeof(addr6_1));
-
-    ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, address6, &len );
-    ok( !ret, "WSAAddressToStringW() failed unexpectedly: %d\n", WSAGetLastError() );
-    ok( !lstrcmpW( address6, expect6_1 ), "Wrong string returned\n" );
-    ok( len == ARRAY_SIZE(expect6_1), "Got %d\n", len);
-
-    /* Test a longer IPv6 address */
-    len = ARRAY_SIZE(address6);
-
-    sockaddr6.sin6_family = AF_INET6;
-    sockaddr6.sin6_port = 0x0000;
-    sockaddr6.sin6_scope_id = 0;
-    memcpy (sockaddr6.sin6_addr.s6_addr, addr6_2, sizeof(addr6_2));
-
-    ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, address6, &len );
-    ok( !ret, "WSAAddressToStringW() failed unexpectedly: %d\n", WSAGetLastError() );
-
-    ok( !lstrcmpW( address6, expect6_2 ), "Wrong string returned\n" );
-    ok( len == ARRAY_SIZE(expect6_2), "Got %d\n", len);
-
-    /* Test IPv6 address and port number */
-    len = ARRAY_SIZE(address6);
-
-    sockaddr6.sin6_family = AF_INET6;
-    sockaddr6.sin6_port = 0xfa81;
-    sockaddr6.sin6_scope_id = 0;
-    memcpy (sockaddr6.sin6_addr.s6_addr, addr6_3, sizeof(addr6_3));
-
-    ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, address6, &len );
-    ok( !ret, "WSAAddressToStringW() failed unexpectedly: %d\n", WSAGetLastError() );
-    ok( !lstrcmpW( address6, expect6_3 ),
-        "Expected: %s, got: %s\n", wine_dbgstr_w(expect6_3), wine_dbgstr_w(address6) );
-    ok( len == ARRAY_SIZE(expect6_3), "Got %d\n", len );
-
-    /* Test IPv6 address, port number and scope_id */
-    len = ARRAY_SIZE(address6);
-
-    sockaddr6.sin6_family = AF_INET6;
-    sockaddr6.sin6_port = 0xfa81;
-    sockaddr6.sin6_scope_id = 0x1234;
-    memcpy (sockaddr6.sin6_addr.s6_addr, addr6_3, sizeof(addr6_3));
-
-    ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, address6, &len );
-    ok( !ret, "WSAAddressToStringW() failed unexpectedly: %d\n", WSAGetLastError() );
-    ok( !lstrcmpW( address6, expect6_3_2 ),
-        "Expected: %s, got: %s\n", wine_dbgstr_w(expect6_3_2), wine_dbgstr_w(address6) );
-    ok( len == ARRAY_SIZE(expect6_3_2), "Got %d\n", len );
-
-    /* Test IPv6 address and scope_id */
-    len = ARRAY_SIZE(address6);
-
-    sockaddr6.sin6_family = AF_INET6;
-    sockaddr6.sin6_port = 0x0000;
-    sockaddr6.sin6_scope_id = 0xfffe;
-    memcpy (sockaddr6.sin6_addr.s6_addr, addr6_3, sizeof(addr6_3));
-
-    ret = WSAAddressToStringW( (SOCKADDR*)&sockaddr6, sizeof(sockaddr6), NULL, address6, &len );
-    ok( !ret, "WSAAddressToStringW() failed unexpectedly: %d\n", WSAGetLastError() );
-    ok( !lstrcmpW( address6, expect6_3_3 ),
-        "Expected: %s, got: %s\n", wine_dbgstr_w(expect6_3_3), wine_dbgstr_w(address6) );
-    ok( len == ARRAY_SIZE(expect6_3_3), "Got %d\n", len );
-
-end:
-    if (v6 != INVALID_SOCKET)
-        closesocket(v6);
 }
 
 static void test_WSAStringToAddress(void)
@@ -11579,10 +11381,7 @@ START_TEST( sock )
     test_WSASocket();
     test_WSADuplicateSocket();
     test_WSAEnumNetworkEvents();
-
-    test_WSAAddressToStringA();
-    test_WSAAddressToStringW();
-
+    test_WSAAddressToString();
     test_WSAStringToAddress();
 
     test_errors();

From 60c8c78015b12493eb3984feef29103724a758af Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 10 Jun 2020 21:22:51 +0300
Subject: [PATCH] ws2_32: Optimize interface_bind_check() by caching adapter
 addresses.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=48668
Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/socket.c | 65 ++++++++++++++++++++++++++++++--------------
 1 file changed, 44 insertions(+), 21 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 199b7187a87..87446025646 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -277,6 +277,17 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION csWSgetXXXbyYYY = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+static in_addr_t *if_addr_cache;
+static unsigned int if_addr_cache_size;
+static CRITICAL_SECTION cs_if_addr_cache;
+static CRITICAL_SECTION_DEBUG cs_if_addr_cache_debug =
+{
+    0, 0, &cs_if_addr_cache,
+    { &cs_if_addr_cache_debug.ProcessLocksList, &cs_if_addr_cache_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": cs_if_addr_cache") }
+};
+static CRITICAL_SECTION cs_if_addr_cache = { &cs_if_addr_cache_debug, -1, 0, 0, 0, 0 };
+
 union generic_unix_sockaddr
 {
     struct sockaddr addr;
@@ -3348,6 +3359,33 @@ static BOOL interface_bind( SOCKET s, int fd, struct sockaddr *addr )
             FIXME("Broadcast packets on interface-bound sockets are not currently supported on this platform, "
                   "receiving broadcast packets will not work on socket %04lx.\n", s);
 #endif
+            if (ret)
+            {
+                EnterCriticalSection(&cs_if_addr_cache);
+                if (if_addr_cache_size <= adapter->Index)
+                {
+                    unsigned int new_size;
+                    in_addr_t *new;
+
+                    new_size = max(if_addr_cache_size * 2, adapter->Index + 1);
+                    if (!(new = heap_realloc(if_addr_cache, sizeof(*if_addr_cache) * new_size)))
+                    {
+                        ERR("No memory.\n");
+                        ret = FALSE;
+                        LeaveCriticalSection(&cs_if_addr_cache);
+                        break;
+                    }
+                    memset(new + if_addr_cache_size, 0, sizeof(*if_addr_cache)
+                            * (new_size - if_addr_cache_size));
+                    if_addr_cache = new;
+                    if_addr_cache_size = new_size;
+                }
+                if (if_addr_cache[adapter->Index] && if_addr_cache[adapter->Index] != adapter_addr)
+                    WARN("Adapter addr for iface index %u has changed.\n", adapter->Index);
+
+                if_addr_cache[adapter->Index] = adapter_addr;
+                LeaveCriticalSection(&cs_if_addr_cache);
+            }
             break;
         }
     }
@@ -3752,27 +3790,12 @@ static void interface_bind_check(int fd, struct sockaddr_in *addr)
 #endif
     if (!ret)
     {
-        PIP_ADAPTER_INFO adapters, adapter;
-        DWORD adap_size;
-
-        if (GetAdaptersInfo(NULL, &adap_size) != ERROR_BUFFER_OVERFLOW)
-            return;
-        adapters = HeapAlloc(GetProcessHeap(), 0, adap_size);
-        if (adapters && GetAdaptersInfo(adapters, &adap_size) == NO_ERROR)
-        {
-            /* Search the IPv4 adapter list for the appropriate bound interface */
-            for (adapter = adapters; adapter != NULL; adapter = adapter->Next)
-            {
-                in_addr_t adapter_addr;
-                if (adapter->Index != ifindex) continue;
-
-                adapter_addr = inet_addr(adapter->IpAddressList.IpAddress.String);
-                addr->sin_addr.s_addr = adapter_addr;
-                TRACE("reporting interface address from adapter %d\n", ifindex);
-                break;
-            }
-        }
-        HeapFree(GetProcessHeap(), 0, adapters);
+        EnterCriticalSection(&cs_if_addr_cache);
+        if (ifindex < if_addr_cache_size)
+            addr->sin_addr.s_addr = if_addr_cache[ifindex];
+        else
+            ERR("No cache entry for ifindex %u.\n", ifindex);
+        LeaveCriticalSection(&cs_if_addr_cache);
     }
 #endif
 }
From 6d1fea9711d5062fdcfe5043091451c8aec56023 Mon Sep 17 00:00:00 2001
From: Louis Lenders <xerox.xerox2000x@gmail.com>
Date: Wed, 17 Jun 2020 00:43:22 +0200
Subject: [PATCH] ws2_32: Add FreeAddrInfoEx.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=48256
Signed-off-by: Louis Lenders <xerox.xerox2000x@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/socket.c    | 18 ++++++++++++++++++
 dlls/ws2_32/ws2_32.spec |  1 +
 include/ws2tcpip.h      |  4 ++++
 3 files changed, 23 insertions(+)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 87446025646..402ee86d962 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -7268,6 +7268,24 @@ void WINAPI FreeAddrInfoW(PADDRINFOW ai)
     }
 }
 
+/***********************************************************************
+ *      FreeAddrInfoEx      (WS2_32.@)
+ */
+void WINAPI FreeAddrInfoEx(ADDRINFOEXA *ai)
+{
+    TRACE("(%p)\n", ai);
+
+    while (ai)
+    {
+        ADDRINFOEXA *next;
+        HeapFree(GetProcessHeap(), 0, ai->ai_canonname);
+        HeapFree(GetProcessHeap(), 0, ai->ai_addr);
+        next = ai->ai_next;
+        HeapFree(GetProcessHeap(), 0, ai);
+        ai = next;
+    }
+}
+
 /***********************************************************************
  *      FreeAddrInfoExW      (WS2_32.@)
  */
diff --git a/dlls/ws2_32/ws2_32.spec b/dlls/ws2_32/ws2_32.spec
index d3c1e6214af..87e0bdfa2f0 100644
--- a/dlls/ws2_32/ws2_32.spec
+++ b/dlls/ws2_32/ws2_32.spec
@@ -50,6 +50,7 @@
 
 500 stub     WEP
 
+@ stdcall FreeAddrInfoEx(ptr)
 @ stdcall FreeAddrInfoExW(ptr)
 @ stdcall FreeAddrInfoW(ptr)
 @ stdcall GetAddrInfoExCancel(ptr)
diff --git a/include/ws2tcpip.h b/include/ws2tcpip.h
index 43c277fa0cb..5a444dcb5f3 100644
--- a/include/ws2tcpip.h
+++ b/include/ws2tcpip.h
@@ -177,7 +177,11 @@ void WINAPI WS(freeaddrinfo)(LPADDRINFO);
 #define     FreeAddrInfoA WS(freeaddrinfo)
 void WINAPI FreeAddrInfoW(PADDRINFOW);
 #define     FreeAddrInfo WINELIB_NAME_AW(FreeAddrInfo)
+void WINAPI FreeAddrInfoEx(ADDRINFOEXA*);
 void WINAPI FreeAddrInfoExW(ADDRINFOEXW*);
+#ifdef UNICODE
+#define     FreeAddrInfoEx FreeAddrInfoExW
+#endif
 int WINAPI  WS(getaddrinfo)(const char*,const char*,const struct WS(addrinfo)*,struct WS(addrinfo)**);
 #define     GetAddrInfoA WS(getaddrinfo)
 int WINAPI  GetAddrInfoW(PCWSTR,PCWSTR,const ADDRINFOW*,PADDRINFOW*);

From 93aea5d86fe2eb50a9bb0829533ca5da627908f6 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 11 Jun 2020 10:21:37 +0200
Subject: [PATCH] include: Add winhttp web socket defines.

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 include/winhttp.h | 48 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 48 insertions(+)

diff --git a/include/winhttp.h b/include/winhttp.h
index 33fc1f915dd..ddfda480880 100644
--- a/include/winhttp.h
+++ b/include/winhttp.h
@@ -762,6 +762,54 @@ typedef struct _WINHTTP_REQUEST_STATS
     ULONGLONG rgullStats[WinHttpRequestStatMax];
 } WINHTTP_REQUEST_STATS, *PWINHTTP_REQUEST_STATS;
 
+typedef enum _WINHTTP_WEB_SOCKET_OPERATION
+{
+    WINHTTP_WEB_SOCKET_SEND_OPERATION     = 0,
+    WINHTTP_WEB_SOCKET_RECEIVE_OPERATION  = 1,
+    WINHTTP_WEB_SOCKET_CLOSE_OPERATION    = 2,
+    WINHTTP_WEB_SOCKET_SHUTDOWN_OPERATION = 3
+} WINHTTP_WEB_SOCKET_OPERATION;
+
+typedef enum _WINHTTP_WEB_SOCKET_BUFFER_TYPE
+{
+    WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE  = 0,
+    WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE = 1,
+    WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE    = 2,
+    WINHTTP_WEB_SOCKET_UTF8_FRAGMENT_BUFFER_TYPE   = 3,
+    WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE           = 4
+} WINHTTP_WEB_SOCKET_BUFFER_TYPE;
+
+typedef enum _WINHTTP_WEB_SOCKET_CLOSE_STATUS
+{
+    WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS                = 1000,
+    WINHTTP_WEB_SOCKET_ENDPOINT_TERMINATED_CLOSE_STATUS    = 1001,
+    WINHTTP_WEB_SOCKET_PROTOCOL_ERROR_CLOSE_STATUS         = 1002,
+    WINHTTP_WEB_SOCKET_INVALID_DATA_TYPE_CLOSE_STATUS      = 1003,
+    WINHTTP_WEB_SOCKET_EMPTY_CLOSE_STATUS                  = 1005,
+    WINHTTP_WEB_SOCKET_ABORTED_CLOSE_STATUS                = 1006,
+    WINHTTP_WEB_SOCKET_INVALID_PAYLOAD_CLOSE_STATUS        = 1007,
+    WINHTTP_WEB_SOCKET_POLICY_VIOLATION_CLOSE_STATUS       = 1008,
+    WINHTTP_WEB_SOCKET_MESSAGE_TOO_BIG_CLOSE_STATUS        = 1009,
+    WINHTTP_WEB_SOCKET_UNSUPPORTED_EXTENSIONS_CLOSE_STATUS = 1010,
+    WINHTTP_WEB_SOCKET_SERVER_ERROR_CLOSE_STATUS           = 1011,
+    WINHTTP_WEB_SOCKET_SECURE_HANDSHAKE_ERROR_CLOSE_STATUS = 1015
+} WINHTTP_WEB_SOCKET_CLOSE_STATUS;
+
+typedef struct _WINHTTP_WEB_SOCKET_ASYNC_RESULT
+{
+    WINHTTP_ASYNC_RESULT AsyncResult;
+    WINHTTP_WEB_SOCKET_OPERATION Operation;
+} WINHTTP_WEB_SOCKET_ASYNC_RESULT;
+
+typedef struct _WINHTTP_WEB_SOCKET_STATUS
+{
+    DWORD dwBytesTransferred;
+    WINHTTP_WEB_SOCKET_BUFFER_TYPE eBufferType;
+} WINHTTP_WEB_SOCKET_STATUS;
+
+#define WINHTTP_WEB_SOCKET_MAX_CLOSE_REASON_LENGTH   123
+#define WINHTTP_WEB_SOCKET_MIN_KEEPALIVE_VALUE     15000
+
 #ifdef __cplusplus
 extern "C" {
 #endif
From 0a90d0431d8d6d2f4913cdc6640edeb1ade833c0 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Thu, 11 Jun 2020 10:21:38 +0200
Subject: [PATCH] winhttp: Add WinHttpWebSocket* function stubs.

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c    | 38 ++++++++++++++++++++++++++++++++++++++
 dlls/winhttp/winhttp.spec |  6 ++++++
 include/winhttp.h         |  6 ++++++
 3 files changed, 50 insertions(+)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index fbccf0228b9..79d66fd5e80 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3013,6 +3013,44 @@ BOOL WINAPI WinHttpWriteData( HINTERNET hrequest, LPCVOID buffer, DWORD to_write
     return !ret;
 }
 
+HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR context )
+{
+    FIXME("%p, %08lx\n", hrequest, context);
+    return NULL;
+}
+
+DWORD WINAPI WinHttpWebSocketSend( HINTERNET hsocket, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, void *buf, DWORD len )
+{
+    FIXME("%p, %u, %p, %u\n", hsocket, type, buf, len);
+    return ERROR_INVALID_PARAMETER;
+}
+
+DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, DWORD *read,
+                                      WINHTTP_WEB_SOCKET_BUFFER_TYPE *type )
+{
+    FIXME("%p, %p, %u, %p, %p\n", hsocket, buf, len, read, type);
+    return ERROR_INVALID_PARAMETER;
+}
+
+DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
+{
+    FIXME("%p, %u, %p, %u\n", hsocket, status, reason, len);
+    return ERROR_INVALID_PARAMETER;
+}
+
+DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
+{
+    FIXME("%p, %u, %p, %u\n", hsocket, status, reason, len);
+    return ERROR_INVALID_PARAMETER;
+}
+
+DWORD WINAPI WinHttpWebSocketQueryCloseStatus( HINTERNET hsocket, USHORT *status, void *reason, DWORD len,
+                                               DWORD *consumed )
+{
+    FIXME("%p, %p, %p, %u, %p\n", hsocket, status, reason, len, consumed);
+    return ERROR_INVALID_PARAMETER;
+}
+
 enum request_state
 {
     REQUEST_STATE_INITIALIZED,
diff --git a/dlls/winhttp/winhttp.spec b/dlls/winhttp/winhttp.spec
index 28dcb1598b7..beace245a8c 100644
--- a/dlls/winhttp/winhttp.spec
+++ b/dlls/winhttp/winhttp.spec
@@ -28,4 +28,10 @@
 @ stdcall WinHttpSetTimeouts(ptr long long long long)
 @ stdcall WinHttpTimeFromSystemTime(ptr ptr)
 @ stdcall WinHttpTimeToSystemTime(wstr ptr)
+@ stdcall WinHttpWebSocketClose(ptr long ptr long)
+@ stdcall WinHttpWebSocketCompleteUpgrade(ptr ptr)
+@ stdcall WinHttpWebSocketQueryCloseStatus(ptr ptr ptr long ptr)
+@ stdcall WinHttpWebSocketReceive(ptr ptr long ptr ptr)
+@ stdcall WinHttpWebSocketSend(ptr long ptr long)
+@ stdcall WinHttpWebSocketShutdown(ptr long ptr long)
 @ stdcall WinHttpWriteData(ptr ptr long ptr)
diff --git a/include/winhttp.h b/include/winhttp.h
index ddfda480880..930c5891f5e 100644
--- a/include/winhttp.h
+++ b/include/winhttp.h
@@ -853,6 +853,12 @@ WINHTTP_STATUS_CALLBACK WINAPI WinHttpSetStatusCallback(HINTERNET,WINHTTP_STATUS
 BOOL        WINAPI WinHttpSetTimeouts(HINTERNET,int,int,int,int);
 BOOL        WINAPI WinHttpTimeFromSystemTime(const SYSTEMTIME *,LPWSTR);
 BOOL        WINAPI WinHttpTimeToSystemTime(LPCWSTR,SYSTEMTIME*);
+DWORD       WINAPI WinHttpWebSocketClose(HINTERNET,USHORT,void *,DWORD);
+HINTERNET   WINAPI WinHttpWebSocketCompleteUpgrade(HINTERNET,DWORD_PTR);
+DWORD       WINAPI WinHttpWebSocketQueryCloseStatus(HINTERNET,USHORT*,void*,DWORD,DWORD*);
+DWORD       WINAPI WinHttpWebSocketReceive(HINTERNET,void*,DWORD,DWORD*,WINHTTP_WEB_SOCKET_BUFFER_TYPE*);
+DWORD       WINAPI WinHttpWebSocketSend(HINTERNET,WINHTTP_WEB_SOCKET_BUFFER_TYPE,void*,DWORD);
+DWORD       WINAPI WinHttpWebSocketShutdown(HINTERNET,USHORT,void*,DWORD);
 BOOL        WINAPI WinHttpWriteData(HINTERNET,LPCVOID,DWORD,LPDWORD);
 DWORD       WINAPI WinHttpWriteProxySettings(HINTERNET,BOOL,WINHTTP_PROXY_SETTINGS*);
 
From a46d359e91e299142a27570bb202d8141b9625da Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 16 Jun 2020 11:45:12 +0200
Subject: [PATCH] winhttp/tests: Add WebSocket tests.

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/tests/winhttp.c | 215 +++++++++++++++++++++++++++++++++++
 1 file changed, 215 insertions(+)

diff --git a/dlls/winhttp/tests/winhttp.c b/dlls/winhttp/tests/winhttp.c
index ab91940ebb8..f08f50b9a9d 100644
--- a/dlls/winhttp/tests/winhttp.c
+++ b/dlls/winhttp/tests/winhttp.c
@@ -37,6 +37,8 @@
 
 DEFINE_GUID(GUID_NULL,0,0,0,0,0,0,0,0,0,0,0);
 
+static HINTERNET (WINAPI *pWinHttpWebSocketCompleteUpgrade)(HINTERNET,DWORD_PTR);
+
 static BOOL proxy_active(void)
 {
     WINHTTP_PROXY_INFO proxy_info;
@@ -2205,6 +2207,12 @@ static const char passportauth[] =
 "WWW-Authenticate: Passport1.4\r\n"
 "\r\n";
 
+static const char switchprotocols[] =
+"HTTP/1.1 101 Switching Protocols\r\n"
+"Server: winetest\r\n"
+"Upgrade: websocket\r\n"
+"Connection: Upgrade\r\n";
+
 static const char unauthorized[] = "Unauthorized";
 static const char hello_world[] = "Hello World";
 static const char auth_unseen[] = "Auth Unseen";
@@ -2217,6 +2225,31 @@ struct server_info
 
 #define BIG_BUFFER_LEN 0x2250
 
+static void create_websocket_accept(const char *key, char *buf, unsigned int buflen)
+{
+    HCRYPTPROV provider;
+    HCRYPTHASH hash;
+    BYTE sha1[20];
+    char data[128];
+    DWORD len;
+
+    strcpy(data, key);
+    strcat(data, "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
+
+    CryptAcquireContextW(&provider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
+    CryptCreateHash(provider, CALG_SHA1, 0, 0, &hash);
+    CryptHashData(hash, (BYTE *)data, strlen(data), 0);
+
+    len = sizeof(sha1);
+    CryptGetHashParam(hash, HP_HASHVAL, sha1, &len, 0);
+    CryptDestroyHash(hash);
+    CryptReleaseContext(provider, 0);
+
+    buf[0] = 0;
+    len = buflen;
+    CryptBinaryToStringA( (BYTE *)sha1, sizeof(sha1), CRYPT_STRING_BASE64, buf, &len);
+}
+
 static DWORD CALLBACK server_thread(LPVOID param)
 {
     struct server_info *si = param;
@@ -2388,6 +2421,29 @@ static DWORD CALLBACK server_thread(LPVOID param)
         {
             send(c, passportauth, sizeof(passportauth) - 1, 0);
         }
+        else if (strstr(buffer, "GET /websocket"))
+        {
+            char headers[256], key[32], accept[64];
+            const char *pos = strstr(buffer, "Sec-WebSocket-Key: ");
+            if (pos && strstr(buffer, "Connection: Upgrade\r\n") &&
+                (strstr(buffer, "Upgrade: websocket\r\n") || strstr(buffer, "Upgrade: Websocket\r\n")) &&
+                strstr(buffer, "Host: ") && strstr(buffer, "Sec-WebSocket-Version: 13\r\n"))
+            {
+                memcpy(headers, switchprotocols, sizeof(switchprotocols));
+                memcpy(key, pos + 19, 24);
+                key[24] = 0;
+
+                create_websocket_accept(key, accept, sizeof(accept));
+
+                strcat(headers, "Sec-WebSocket-Accept: ");
+                strcat(headers, accept);
+                strcat(headers, "\r\n\r\n");
+
+                send(c, headers, strlen(headers), 0);
+            }
+            else send(c, notokmsg, sizeof(notokmsg) - 1, 0);
+            continue;
+        }
         if (strstr(buffer, "GET /quit"))
         {
             send(c, okmsg, sizeof okmsg - 1, 0);
@@ -3039,6 +3095,161 @@ static void test_head_request(int port)
     WinHttpCloseHandle(ses);
 }
 
+static void test_websocket(int port)
+{
+    HINTERNET session, connection, request, socket;
+    DWORD size, len, count, status, index, error;
+    WCHAR header[32];
+    char buf[128];
+    BOOL ret;
+
+    if (!pWinHttpWebSocketCompleteUpgrade)
+    {
+        win_skip("WinHttpWebSocketCompleteUpgrade not supported\n");
+        return;
+    }
+
+    session = WinHttpOpen(L"winetest", 0, NULL, NULL, 0);
+    ok(session != NULL, "got %u\n", GetLastError());
+
+    connection = WinHttpConnect(session, L"localhost", port, 0);
+    ok(connection != NULL, "got %u\n", GetLastError());
+
+    request = WinHttpOpenRequest(connection, L"GET", L"/websocket", NULL, NULL, NULL, 0);
+    ok(request != NULL, "got %u\n", GetLastError());
+
+    ret = WinHttpSetOption(request, WINHTTP_OPTION_UPGRADE_TO_WEB_SOCKET, NULL, 0);
+    todo_wine ok(ret, "got %u\n", GetLastError());
+
+    size = sizeof(header);
+    SetLastError(0xdeadbeef);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_UPGRADE, NULL, &header, &size, NULL);
+    error = GetLastError();
+    ok(!ret, "success\n");
+    todo_wine ok(error == ERROR_WINHTTP_INCORRECT_HANDLE_STATE, "got %u\n", error);
+
+    size = sizeof(header);
+    SetLastError(0xdeadbeef);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CONNECTION, NULL, &header, &size, NULL);
+    error = GetLastError();
+    ok(!ret, "success\n");
+    todo_wine ok(error == ERROR_WINHTTP_INCORRECT_HANDLE_STATE, "got %u\n", error);
+
+    index = 0;
+    size = sizeof(buf);
+    SetLastError(0xdeadbeef);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_REQUEST_HEADERS,
+                              L"Sec-WebSocket-Key", buf, &size, &index);
+    error = GetLastError();
+    ok(!ret, "success\n");
+    ok(error == ERROR_WINHTTP_HEADER_NOT_FOUND, "got %u\n", error);
+
+    index = 0;
+    size = sizeof(buf);
+    SetLastError(0xdeadbeef);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_REQUEST_HEADERS,
+                              L"Sec-WebSocket-Version", buf, &size, &index);
+    error = GetLastError();
+    ok(!ret, "success\n");
+    ok(error == ERROR_WINHTTP_HEADER_NOT_FOUND, "got %u\n", error);
+
+    ret = WinHttpSendRequest(request, NULL, 0, NULL, 0, 0, 0);
+    ok(ret, "got %u\n", GetLastError());
+
+    size = sizeof(header);
+    SetLastError(0xdeadbeef);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_UPGRADE, NULL, &header, &size, NULL);
+    error = GetLastError();
+    ok(!ret, "success\n");
+    todo_wine ok(error == ERROR_WINHTTP_INCORRECT_HANDLE_STATE, "got %u\n", error);
+
+    size = sizeof(header);
+    SetLastError(0xdeadbeef);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CONNECTION, NULL, &header, &size, NULL);
+    error = GetLastError();
+    ok(!ret, "success\n");
+    todo_wine ok(error == ERROR_WINHTTP_INCORRECT_HANDLE_STATE, "got %u\n", error);
+
+    index = 0;
+    buf[0] = 0;
+    size = sizeof(buf);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_REQUEST_HEADERS,
+                              L"Sec-WebSocket-Key", buf, &size, &index);
+    todo_wine ok(ret, "got %u\n", GetLastError());
+
+    index = 0;
+    buf[0] = 0;
+    size = sizeof(buf);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_REQUEST_HEADERS,
+                              L"Sec-WebSocket-Version", buf, &size, &index);
+    todo_wine ok(ret, "got %u\n", GetLastError());
+
+    ret = WinHttpReceiveResponse(request, NULL);
+    todo_wine ok(ret, "got %u\n", GetLastError());
+
+    count = 0xdeadbeef;
+    ret = WinHttpQueryDataAvailable(request, &count);
+    ok(ret, "got %u\n", GetLastError());
+    todo_wine ok(!count, "got %u\n", count);
+
+    header[0] = 0;
+    size = sizeof(header);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_UPGRADE, NULL, &header, &size, NULL);
+    todo_wine ok(ret, "got %u\n", GetLastError());
+    todo_wine ok(!wcscmp( header, L"websocket" ), "got %s\n", wine_dbgstr_w(header));
+
+    header[0] = 0;
+    size = sizeof(header);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CONNECTION, NULL, &header, &size, NULL);
+    todo_wine ok(ret, "got %u\n", GetLastError());
+    todo_wine ok(!wcscmp( header, L"Upgrade" ), "got %s\n", wine_dbgstr_w(header));
+
+    status = 0xdeadbeef;
+    size = sizeof(status);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, NULL, &status,
+                              &size, NULL);
+    ok(ret, "got %u\n", GetLastError());
+    todo_wine ok(status == HTTP_STATUS_SWITCH_PROTOCOLS, "got %u\n", status);
+
+    len = 0xdeadbeef;
+    size = sizeof(len);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CONTENT_LENGTH | WINHTTP_QUERY_FLAG_NUMBER, NULL, &len,
+                              &size, 0);
+    ok(!ret, "success\n");
+
+    index = 0;
+    size = sizeof(buf);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CUSTOM, L"Sec-WebSocket-Accept", buf, &size, &index);
+    todo_wine ok(ret, "got %u\n", GetLastError());
+
+    socket = pWinHttpWebSocketCompleteUpgrade(request, 0);
+    todo_wine ok(socket != NULL, "got %u\n", GetLastError());
+
+    header[0] = 0;
+    size = sizeof(header);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_UPGRADE, NULL, &header, &size, NULL);
+    todo_wine ok(ret, "got %u\n", GetLastError());
+    todo_wine ok(!wcscmp( header, L"websocket" ), "got %s\n", wine_dbgstr_w(header));
+
+    header[0] = 0;
+    size = sizeof(header);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CONNECTION, NULL, &header, &size, NULL);
+    todo_wine ok(ret, "got %u\n", GetLastError());
+    todo_wine ok(!wcscmp( header, L"Upgrade" ), "got %s\n", wine_dbgstr_w(header));
+
+    index = 0;
+    size = sizeof(buf);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CUSTOM, L"Sec-WebSocket-Accept", buf, &size, &index);
+    todo_wine ok(ret, "got %u\n", GetLastError());
+
+    /* Send/Receive on websock */
+
+    WinHttpCloseHandle(request);
+    WinHttpCloseHandle(socket);
+    WinHttpCloseHandle(connection);
+    WinHttpCloseHandle(session);
+}
+
 static void test_not_modified(int port)
 {
     BOOL ret;
@@ -4710,6 +4921,9 @@ START_TEST (winhttp)
     struct server_info si;
     HANDLE thread;
     DWORD ret;
+    HMODULE mod = GetModuleHandleA("winhttp.dll");
+
+    pWinHttpWebSocketCompleteUpgrade = (void *)GetProcAddress(mod, "WinHttpWebSocketCompleteUpgrade");
 
     test_WinHttpOpenRequest();
     test_WinHttpSendRequest();
@@ -4759,6 +4973,7 @@ START_TEST (winhttp)
     test_cookies(si.port);
     test_request_path_escapes(si.port);
     test_passport_auth(si.port);
+    test_websocket(si.port);
 
     /* send the basic request again to shutdown the server thread */
     test_basic_request(si.port, NULL, L"/quit");
From aa80ef20504660fa55914d40fb4bb296eef94c59 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Tue, 16 Jun 2020 13:48:22 -0700
Subject: [PATCH] winhttp: Treat a partial certificate chain as having an
 unknown/invalid CA.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=46726
Signed-off-by: Brendan Shanks <bshanks@codeweavers.com>
Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/net.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/winhttp/net.c b/dlls/winhttp/net.c
index 2905d5c535a..0cc2bb2bef7 100644
--- a/dlls/winhttp/net.c
+++ b/dlls/winhttp/net.c
@@ -84,8 +84,10 @@ static DWORD netconn_verify_cert( PCCERT_CONTEXT cert, WCHAR *server, DWORD secu
                 if (!(security_flags & SECURITY_FLAG_IGNORE_CERT_DATE_INVALID))
                     err = ERROR_WINHTTP_SECURE_CERT_DATE_INVALID;
             }
-            else if (chain->TrustStatus.dwErrorStatus &
-                     CERT_TRUST_IS_UNTRUSTED_ROOT)
+            else if ((chain->TrustStatus.dwErrorStatus &
+                      CERT_TRUST_IS_UNTRUSTED_ROOT) ||
+                     (chain->TrustStatus.dwErrorStatus &
+                      CERT_TRUST_IS_PARTIAL_CHAIN))
             {
                 if (!(security_flags & SECURITY_FLAG_IGNORE_UNKNOWN_CA))
                     err = ERROR_WINHTTP_SECURE_INVALID_CA;
From a6de059eef5e0aa4aa688885c1d91497c588576f Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Wed, 17 Jun 2020 11:53:40 +0200
Subject: [PATCH] winhttp: Status HTTP_STATUS_SWITCH_PROTOCOLS doesn't have any
 content.

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 79d66fd5e80..9173bdb56d1 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -2353,8 +2353,11 @@ static void set_content_length( struct request *request, DWORD status )
     WCHAR encoding[20];
     DWORD buflen = sizeof(request->content_length);
 
-    if (status == HTTP_STATUS_NO_CONTENT || status == HTTP_STATUS_NOT_MODIFIED || !wcscmp( request->verb, L"HEAD" ))
+    if (status == HTTP_STATUS_NO_CONTENT || status == HTTP_STATUS_NOT_MODIFIED ||
+        status == HTTP_STATUS_SWITCH_PROTOCOLS || !wcscmp( request->verb, L"HEAD" ))
+    {
         request->content_length = 0;
+    }
     else
     {
         if (query_headers( request, WINHTTP_QUERY_CONTENT_LENGTH|WINHTTP_QUERY_FLAG_NUMBER,
From 0b48050da58be2ee72bcc5c4848822d6853d857c Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 17 Jun 2020 11:53:41 +0200
Subject: [PATCH] winhttp: Implement WinHttpWebSocketCompleteUpgrade.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 101 ++++++++++++++++++++++++++++++++-
 dlls/winhttp/session.c         |  13 ++---
 dlls/winhttp/tests/winhttp.c   |  34 +++++------
 dlls/winhttp/winhttp_private.h |  14 +++++
 4 files changed, 133 insertions(+), 29 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 9173bdb56d1..0511dd44eec 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -33,6 +33,7 @@
 #include "httprequestid.h"
 #include "schannel.h"
 #include "winhttp.h"
+#include "ntsecapi.h"
 
 #include "wine/debug.h"
 #include "winhttp_private.h"
@@ -2098,6 +2099,25 @@ static char *build_wire_request( struct request *request, DWORD *len )
     return ret;
 }
 
+static WCHAR *create_websocket_key(void)
+{
+    WCHAR *ret;
+    char buf[16];
+    DWORD base64_len = ((sizeof(buf) + 2) * 4) / 3;
+    if (!RtlGenRandom( buf, sizeof(buf) )) return NULL;
+    if ((ret = heap_alloc( (base64_len + 1) * sizeof(WCHAR) ))) encode_base64( buf, sizeof(buf), ret );
+    return ret;
+}
+
+static DWORD add_websocket_key_header( struct request *request )
+{
+    WCHAR *key = create_websocket_key();
+    if (!key) return ERROR_OUTOFMEMORY;
+    process_header( request, L"Sec-WebSocket-Key", key, WINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE, TRUE );
+    heap_free( key );
+    return ERROR_SUCCESS;
+}
+
 static DWORD send_request( struct request *request, const WCHAR *headers, DWORD headers_len, void *optional,
                            DWORD optional_len, DWORD total_len, DWORD_PTR context, BOOL async )
 {
@@ -2125,7 +2145,14 @@ static DWORD send_request( struct request *request, const WCHAR *headers, DWORD
         swprintf( length, ARRAY_SIZE(length), L"%ld", total_len );
         process_header( request, L"Content-Length", length, WINHTTP_ADDREQ_FLAG_ADD_IF_NEW, TRUE );
     }
-    if (!(request->hdr.disable_flags & WINHTTP_DISABLE_KEEP_ALIVE))
+    if (request->flags & REQUEST_FLAG_WEBSOCKET_UPGRADE)
+    {
+        process_header( request, L"Upgrade", L"websocket", WINHTTP_ADDREQ_FLAG_ADD_IF_NEW, TRUE );
+        process_header( request, L"Connection", L"Upgrade", WINHTTP_ADDREQ_FLAG_ADD_IF_NEW, TRUE );
+        process_header( request, L"Sec-WebSocket-Version", L"13", WINHTTP_ADDREQ_FLAG_ADD_IF_NEW, TRUE );
+        if ((ret = add_websocket_key_header( request ))) return ret;
+    }
+    else if (!(request->hdr.disable_flags & WINHTTP_DISABLE_KEEP_ALIVE))
     {
         process_header( request, L"Connection", L"Keep-Alive", WINHTTP_ADDREQ_FLAG_ADD_IF_NEW, TRUE );
     }
@@ -3016,10 +3043,78 @@ BOOL WINAPI WinHttpWriteData( HINTERNET hrequest, LPCVOID buffer, DWORD to_write
     return !ret;
 }
 
+static BOOL socket_query_option( struct object_header *hdr, DWORD option, void *buffer, DWORD *buflen )
+{
+    FIXME("unimplemented option %u\n", option);
+    SetLastError( ERROR_WINHTTP_INVALID_OPTION );
+    return FALSE;
+}
+
+static void socket_destroy( struct object_header *hdr )
+{
+    struct socket *socket = (struct socket *)hdr;
+
+    TRACE("%p\n", socket);
+
+    release_object( &socket->request->hdr );
+    heap_free( socket );
+}
+
+static BOOL socket_set_option( struct object_header *hdr, DWORD option, void *buffer, DWORD buflen )
+{
+    FIXME("unimplemented option %u\n", option);
+    SetLastError( ERROR_WINHTTP_INVALID_OPTION );
+    return FALSE;
+}
+
+static const struct object_vtbl socket_vtbl =
+{
+    socket_destroy,
+    socket_query_option,
+    socket_set_option,
+};
+
 HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR context )
 {
-    FIXME("%p, %08lx\n", hrequest, context);
-    return NULL;
+    struct socket *socket;
+    struct request *request;
+    HINTERNET hsocket = NULL;
+
+    TRACE("%p, %08lx\n", hrequest, context);
+
+    if (!(request = (struct request *)grab_object( hrequest )))
+    {
+        SetLastError( ERROR_INVALID_HANDLE );
+        return NULL;
+    }
+    if (request->hdr.type != WINHTTP_HANDLE_TYPE_REQUEST)
+    {
+        release_object( &request->hdr );
+        SetLastError( ERROR_WINHTTP_INCORRECT_HANDLE_TYPE );
+        return NULL;
+    }
+    if (!(socket = heap_alloc_zero( sizeof(struct socket) )))
+    {
+        release_object( &request->hdr );
+        return NULL;
+    }
+    socket->hdr.type = WINHTTP_HANDLE_TYPE_SOCKET;
+    socket->hdr.vtbl = &socket_vtbl;
+    socket->hdr.refs = 1;
+    socket->hdr.context = context;
+    list_init( &socket->hdr.children );
+
+    addref_object( &request->hdr );
+    socket->request = request;
+    list_add_head( &request->hdr.children, &socket->hdr.entry );
+
+    if ((hsocket = alloc_handle( &socket->hdr ))) socket->hdr.handle = hsocket;
+
+    release_object( &socket->hdr );
+    release_object( &request->hdr );
+    TRACE("returning %p\n", hsocket);
+    if (hsocket) SetLastError( ERROR_SUCCESS );
+    return hsocket;
 }
 
 DWORD WINAPI WinHttpWebSocketSend( HINTERNET hsocket, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, void *buf, DWORD len )
diff --git a/dlls/winhttp/session.c b/dlls/winhttp/session.c
index 24455d858a6..87974ffbd8e 100644
--- a/dlls/winhttp/session.c
+++ b/dlls/winhttp/session.c
@@ -63,9 +63,6 @@ BOOL WINAPI WinHttpCheckPlatform( void )
     return TRUE;
 }
 
-/***********************************************************************
- *          session_destroy (internal)
- */
 static void session_destroy( struct object_header *hdr )
 {
     struct session *session = (struct session *)hdr;
@@ -296,9 +293,6 @@ HINTERNET WINAPI WinHttpOpen( LPCWSTR agent, DWORD access, LPCWSTR proxy, LPCWST
     return handle;
 }
 
-/***********************************************************************
- *          connect_destroy (internal)
- */
 static void connect_destroy( struct object_header *hdr )
 {
     struct connect *connect = (struct connect *)hdr;
@@ -581,9 +575,6 @@ HINTERNET WINAPI WinHttpConnect( HINTERNET hsession, LPCWSTR server, INTERNET_PO
     return hconnect;
 }
 
-/***********************************************************************
- *          request_destroy (internal)
- */
 static void request_destroy( struct object_header *hdr )
 {
     struct request *request = (struct request *)hdr;
@@ -1038,6 +1029,10 @@ static BOOL request_set_option( struct object_header *hdr, DWORD option, void *b
             return FALSE;
         }
 
+    case WINHTTP_OPTION_UPGRADE_TO_WEB_SOCKET:
+        request->flags |= REQUEST_FLAG_WEBSOCKET_UPGRADE;
+        return TRUE;
+
     case WINHTTP_OPTION_CONNECT_RETRIES:
         FIXME("WINHTTP_OPTION_CONNECT_RETRIES\n");
         return TRUE;
diff --git a/dlls/winhttp/tests/winhttp.c b/dlls/winhttp/tests/winhttp.c
index f08f50b9a9d..8083c4825b2 100644
--- a/dlls/winhttp/tests/winhttp.c
+++ b/dlls/winhttp/tests/winhttp.c
@@ -3119,7 +3119,7 @@ static void test_websocket(int port)
     ok(request != NULL, "got %u\n", GetLastError());
 
     ret = WinHttpSetOption(request, WINHTTP_OPTION_UPGRADE_TO_WEB_SOCKET, NULL, 0);
-    todo_wine ok(ret, "got %u\n", GetLastError());
+    ok(ret, "got %u\n", GetLastError());
 
     size = sizeof(header);
     SetLastError(0xdeadbeef);
@@ -3175,41 +3175,41 @@ static void test_websocket(int port)
     size = sizeof(buf);
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_REQUEST_HEADERS,
                               L"Sec-WebSocket-Key", buf, &size, &index);
-    todo_wine ok(ret, "got %u\n", GetLastError());
+    ok(ret, "got %u\n", GetLastError());
 
     index = 0;
     buf[0] = 0;
     size = sizeof(buf);
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CUSTOM | WINHTTP_QUERY_FLAG_REQUEST_HEADERS,
                               L"Sec-WebSocket-Version", buf, &size, &index);
-    todo_wine ok(ret, "got %u\n", GetLastError());
+    ok(ret, "got %u\n", GetLastError());
 
     ret = WinHttpReceiveResponse(request, NULL);
-    todo_wine ok(ret, "got %u\n", GetLastError());
+    ok(ret, "got %u\n", GetLastError());
 
     count = 0xdeadbeef;
     ret = WinHttpQueryDataAvailable(request, &count);
     ok(ret, "got %u\n", GetLastError());
-    todo_wine ok(!count, "got %u\n", count);
+    ok(!count, "got %u\n", count);
 
     header[0] = 0;
     size = sizeof(header);
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_UPGRADE, NULL, &header, &size, NULL);
-    todo_wine ok(ret, "got %u\n", GetLastError());
-    todo_wine ok(!wcscmp( header, L"websocket" ), "got %s\n", wine_dbgstr_w(header));
+    ok(ret, "got %u\n", GetLastError());
+    ok(!wcscmp( header, L"websocket" ), "got %s\n", wine_dbgstr_w(header));
 
     header[0] = 0;
     size = sizeof(header);
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CONNECTION, NULL, &header, &size, NULL);
-    todo_wine ok(ret, "got %u\n", GetLastError());
-    todo_wine ok(!wcscmp( header, L"Upgrade" ), "got %s\n", wine_dbgstr_w(header));
+    ok(ret, "got %u\n", GetLastError());
+    ok(!wcscmp( header, L"Upgrade" ), "got %s\n", wine_dbgstr_w(header));
 
     status = 0xdeadbeef;
     size = sizeof(status);
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, NULL, &status,
                               &size, NULL);
     ok(ret, "got %u\n", GetLastError());
-    todo_wine ok(status == HTTP_STATUS_SWITCH_PROTOCOLS, "got %u\n", status);
+    ok(status == HTTP_STATUS_SWITCH_PROTOCOLS, "got %u\n", status);
 
     len = 0xdeadbeef;
     size = sizeof(len);
@@ -3220,27 +3220,27 @@ static void test_websocket(int port)
     index = 0;
     size = sizeof(buf);
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CUSTOM, L"Sec-WebSocket-Accept", buf, &size, &index);
-    todo_wine ok(ret, "got %u\n", GetLastError());
+    ok(ret, "got %u\n", GetLastError());
 
     socket = pWinHttpWebSocketCompleteUpgrade(request, 0);
-    todo_wine ok(socket != NULL, "got %u\n", GetLastError());
+    ok(socket != NULL, "got %u\n", GetLastError());
 
     header[0] = 0;
     size = sizeof(header);
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_UPGRADE, NULL, &header, &size, NULL);
-    todo_wine ok(ret, "got %u\n", GetLastError());
-    todo_wine ok(!wcscmp( header, L"websocket" ), "got %s\n", wine_dbgstr_w(header));
+    ok(ret, "got %u\n", GetLastError());
+    ok(!wcscmp( header, L"websocket" ), "got %s\n", wine_dbgstr_w(header));
 
     header[0] = 0;
     size = sizeof(header);
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CONNECTION, NULL, &header, &size, NULL);
-    todo_wine ok(ret, "got %u\n", GetLastError());
-    todo_wine ok(!wcscmp( header, L"Upgrade" ), "got %s\n", wine_dbgstr_w(header));
+    ok(ret, "got %u\n", GetLastError());
+    ok(!wcscmp( header, L"Upgrade" ), "got %s\n", wine_dbgstr_w(header));
 
     index = 0;
     size = sizeof(buf);
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CUSTOM, L"Sec-WebSocket-Accept", buf, &size, &index);
-    todo_wine ok(ret, "got %u\n", GetLastError());
+    ok(ret, "got %u\n", GetLastError());
 
     /* Send/Receive on websock */
 
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 657f82f6421..af695f86c3e 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -26,6 +26,8 @@
 #include "sspi.h"
 #include "wincrypt.h"
 
+#define WINHTTP_HANDLE_TYPE_SOCKET 4
+
 struct object_header;
 struct object_vtbl
 {
@@ -154,10 +156,16 @@ struct authinfo
     BOOL finished; /* finished authenticating */
 };
 
+enum request_flags
+{
+    REQUEST_FLAG_WEBSOCKET_UPGRADE = 0x01,
+};
+
 struct request
 {
     struct object_header hdr;
     struct connect *connect;
+    enum request_flags flags;
     WCHAR *verb;
     WCHAR *path;
     WCHAR *version;
@@ -201,6 +209,12 @@ struct request
     } creds[TARGET_MAX][SCHEME_MAX];
 };
 
+struct socket
+{
+    struct object_header hdr;
+    struct request *request;
+};
+
 struct task_header
 {
     struct list entry;
From 933665147704ab07e702bf4366f1a9a8aa6a62d7 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 22 Jun 2020 21:39:20 +0200
Subject: [PATCH] winhttp: Don't close child handles on release.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/handle.c          | 14 ++------------
 dlls/winhttp/request.c         |  2 --
 dlls/winhttp/session.c         |  5 -----
 dlls/winhttp/tests/winhttp.c   | 27 +++++++++++++++++++++++----
 dlls/winhttp/winhttp_private.h |  1 -
 5 files changed, 25 insertions(+), 24 deletions(-)

diff --git a/dlls/winhttp/handle.c b/dlls/winhttp/handle.c
index 9c77d5166ad..08052b91ee3 100644
--- a/dlls/winhttp/handle.c
+++ b/dlls/winhttp/handle.c
@@ -79,7 +79,6 @@ void release_object( struct object_header *hdr )
         send_callback( hdr, WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING, &hdr->handle, sizeof(HINTERNET) );
 
         TRACE("destroying object %p\n", hdr);
-        if (hdr->type != WINHTTP_HANDLE_TYPE_SESSION) list_remove( &hdr->entry );
         hdr->vtbl->destroy( hdr );
     }
 }
@@ -89,7 +88,6 @@ HINTERNET alloc_handle( struct object_header *hdr )
     struct object_header **p;
     ULONG_PTR handle, num;
 
-    list_init( &hdr->children );
     hdr->handle = NULL;
 
     EnterCriticalSection( &handle_cs );
@@ -123,7 +121,7 @@ BOOL free_handle( HINTERNET hinternet )
 {
     BOOL ret = FALSE;
     ULONG_PTR handle = (ULONG_PTR)hinternet;
-    struct object_header *hdr = NULL, *child, *next;
+    struct object_header *hdr = NULL;
 
     EnterCriticalSection( &handle_cs );
 
@@ -141,15 +139,7 @@ BOOL free_handle( HINTERNET hinternet )
 
     LeaveCriticalSection( &handle_cs );
 
-    if (hdr)
-    {
-        LIST_FOR_EACH_ENTRY_SAFE( child, next, &hdr->children, struct object_header, entry )
-        {
-            TRACE("freeing child handle %p for parent handle 0x%lx\n", child->handle, handle + 1);
-            free_handle( child->handle );
-        }
-        release_object( hdr );
-    }
+    if (hdr) release_object( hdr );
 
     EnterCriticalSection( &handle_cs );
     if (next_handle > handle && !handles[handle]) next_handle = handle;
diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 0511dd44eec..08e9d7584ed 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3102,11 +3102,9 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
     socket->hdr.vtbl = &socket_vtbl;
     socket->hdr.refs = 1;
     socket->hdr.context = context;
-    list_init( &socket->hdr.children );
 
     addref_object( &request->hdr );
     socket->request = request;
-    list_add_head( &request->hdr.children, &socket->hdr.entry );
 
     if ((hsocket = alloc_handle( &socket->hdr ))) socket->hdr.handle = hsocket;
 
diff --git a/dlls/winhttp/session.c b/dlls/winhttp/session.c
index 87974ffbd8e..13d228d8513 100644
--- a/dlls/winhttp/session.c
+++ b/dlls/winhttp/session.c
@@ -246,7 +246,6 @@ HINTERNET WINAPI WinHttpOpen( LPCWSTR agent, DWORD access, LPCWSTR proxy, LPCWST
     session->hdr.flags = flags;
     session->hdr.refs = 1;
     session->hdr.redirect_policy = WINHTTP_OPTION_REDIRECT_POLICY_DISALLOW_HTTPS_TO_HTTP;
-    list_init( &session->hdr.children );
     session->resolve_timeout = DEFAULT_RESOLVE_TIMEOUT;
     session->connect_timeout = DEFAULT_CONNECT_TIMEOUT;
     session->send_timeout = DEFAULT_SEND_TIMEOUT;
@@ -552,11 +551,9 @@ HINTERNET WINAPI WinHttpConnect( HINTERNET hsession, LPCWSTR server, INTERNET_PO
     connect->hdr.notify_mask = session->hdr.notify_mask;
     connect->hdr.context = session->hdr.context;
     connect->hdr.redirect_policy = session->hdr.redirect_policy;
-    list_init( &connect->hdr.children );
 
     addref_object( &session->hdr );
     connect->session = session;
-    list_add_head( &session->hdr.children, &connect->hdr.entry );
 
     if (!(connect->hostname = strdupW( server ))) goto end;
     connect->hostport = port;
@@ -1121,12 +1118,10 @@ HINTERNET WINAPI WinHttpOpenRequest( HINTERNET hconnect, LPCWSTR verb, LPCWSTR o
     request->hdr.notify_mask = connect->hdr.notify_mask;
     request->hdr.context = connect->hdr.context;
     request->hdr.redirect_policy = connect->hdr.redirect_policy;
-    list_init( &request->hdr.children );
     list_init( &request->task_queue );
 
     addref_object( &connect->hdr );
     request->connect = connect;
-    list_add_head( &connect->hdr.children, &request->hdr.entry );
 
     request->resolve_timeout = connect->session->resolve_timeout;
     request->connect_timeout = connect->session->connect_timeout;
diff --git a/dlls/winhttp/tests/winhttp.c b/dlls/winhttp/tests/winhttp.c
index 8083c4825b2..be02bbe2502 100644
--- a/dlls/winhttp/tests/winhttp.c
+++ b/dlls/winhttp/tests/winhttp.c
@@ -3099,6 +3099,7 @@ static void test_websocket(int port)
 {
     HINTERNET session, connection, request, socket;
     DWORD size, len, count, status, index, error;
+    DWORD_PTR ctx;
     WCHAR header[32];
     char buf[128];
     BOOL ret;
@@ -3244,10 +3245,28 @@ static void test_websocket(int port)
 
     /* Send/Receive on websock */
 
-    WinHttpCloseHandle(request);
-    WinHttpCloseHandle(socket);
-    WinHttpCloseHandle(connection);
-    WinHttpCloseHandle(session);
+    ret = WinHttpCloseHandle(connection);
+    ok(ret, "got %u\n", GetLastError());
+
+    /* request handle is still valid */
+    size = sizeof(ctx);
+    ret = WinHttpQueryOption(request, WINHTTP_OPTION_CONTEXT_VALUE, &ctx, &size);
+    ok(ret, "got %u\n", GetLastError());
+
+    ret = WinHttpCloseHandle(socket);
+    ok(ret, "got %u\n", GetLastError());
+
+    ret = WinHttpQueryOption(request, WINHTTP_OPTION_CONTEXT_VALUE, &ctx, &size);
+    ok(ret, "got %u\n", GetLastError());
+
+    ret = WinHttpCloseHandle(session);
+    ok(ret, "got %u\n", GetLastError());
+
+    ret = WinHttpQueryOption(request, WINHTTP_OPTION_CONTEXT_VALUE, &ctx, &size);
+    ok(ret, "got %u\n", GetLastError());
+
+    ret = WinHttpCloseHandle(request);
+    ok(ret, "got %u\n", GetLastError());
 }
 
 static void test_not_modified(int port)
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index af695f86c3e..9b07b64b090 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -51,7 +51,6 @@ struct object_header
     WINHTTP_STATUS_CALLBACK callback;
     DWORD notify_mask;
     struct list entry;
-    struct list children;
 };
 
 struct hostdata
From 5c4f1e4c82ace138fa411cf06421440916d347c3 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 22 Jun 2020 21:39:21 +0200
Subject: [PATCH] winhttp: Get rid of some redundant assignments.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c |  2 +-
 dlls/winhttp/session.c | 19 +++++++++----------
 2 files changed, 10 insertions(+), 11 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 08e9d7584ed..1324005f1d5 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3106,7 +3106,7 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
     addref_object( &request->hdr );
     socket->request = request;
 
-    if ((hsocket = alloc_handle( &socket->hdr ))) socket->hdr.handle = hsocket;
+    hsocket = alloc_handle( &socket->hdr );
 
     release_object( &socket->hdr );
     release_object( &request->hdr );
diff --git a/dlls/winhttp/session.c b/dlls/winhttp/session.c
index 13d228d8513..a5ec8b22f39 100644
--- a/dlls/winhttp/session.c
+++ b/dlls/winhttp/session.c
@@ -282,8 +282,7 @@ HINTERNET WINAPI WinHttpOpen( LPCWSTR agent, DWORD access, LPCWSTR proxy, LPCWST
         if (bypass && !(session->proxy_bypass = strdupW( bypass ))) goto end;
     }
 
-    if (!(handle = alloc_handle( &session->hdr ))) goto end;
-    session->hdr.handle = handle;
+    handle = alloc_handle( &session->hdr );
 
 end:
     release_object( &session->hdr );
@@ -559,10 +558,10 @@ HINTERNET WINAPI WinHttpConnect( HINTERNET hsession, LPCWSTR server, INTERNET_PO
     connect->hostport = port;
     if (!set_server_for_hostname( connect, server, port )) goto end;
 
-    if (!(hconnect = alloc_handle( &connect->hdr ))) goto end;
-    connect->hdr.handle = hconnect;
-
-    send_callback( &session->hdr, WINHTTP_CALLBACK_STATUS_HANDLE_CREATED, &hconnect, sizeof(hconnect) );
+    if ((hconnect = alloc_handle( &connect->hdr )))
+    {
+        send_callback( &session->hdr, WINHTTP_CALLBACK_STATUS_HANDLE_CREATED, &hconnect, sizeof(hconnect) );
+    }
 
 end:
     release_object( &connect->hdr );
@@ -1137,10 +1136,10 @@ HINTERNET WINAPI WinHttpOpenRequest( HINTERNET hconnect, LPCWSTR verb, LPCWSTR o
     if (!(request->version = strdupW( version ))) goto end;
     if (!(add_accept_types_header( request, types ))) goto end;
 
-    if (!(hrequest = alloc_handle( &request->hdr ))) goto end;
-    request->hdr.handle = hrequest;
-
-    send_callback( &request->hdr, WINHTTP_CALLBACK_STATUS_HANDLE_CREATED, &hrequest, sizeof(hrequest) );
+    if ((hrequest = alloc_handle( &request->hdr )))
+    {
+        send_callback( &request->hdr, WINHTTP_CALLBACK_STATUS_HANDLE_CREATED, &hrequest, sizeof(hrequest) );
+    }
 
 end:
     release_object( &request->hdr );
From 6a98d5f524b74c0ec3ea5879be30c929c75042b2 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 22 Jun 2020 21:39:22 +0200
Subject: [PATCH] winhttp: Make the task queue implementation more generic.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 174 +++++++++++++++++----------------
 dlls/winhttp/session.c         |  12 ++-
 dlls/winhttp/winhttp_private.h |  18 ++--
 3 files changed, 109 insertions(+), 95 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 1324005f1d5..9b72253a260 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -121,27 +121,25 @@ static const WCHAR *attribute_table[] =
     NULL                            /* WINHTTP_QUERY_PASSPORT_CONFIG            = 78 */
 };
 
-static struct task_header *dequeue_task( struct request *request )
+static struct task_header *dequeue_task( struct queue *queue )
 {
     struct task_header *task;
 
-    EnterCriticalSection( &request->task_cs );
-    TRACE("%u tasks queued\n", list_count( &request->task_queue ));
-    task = LIST_ENTRY( list_head( &request->task_queue ), struct task_header, entry );
+    EnterCriticalSection( &queue->cs );
+    TRACE("%u tasks queued in %p\n", list_count(&queue->tasks), queue);
+    task = LIST_ENTRY( list_head( &queue->tasks ), struct task_header, entry );
     if (task) list_remove( &task->entry );
-    LeaveCriticalSection( &request->task_cs );
+    LeaveCriticalSection( &queue->cs );
 
     TRACE("returning task %p\n", task);
     return task;
 }
 
-static void CALLBACK task_proc( TP_CALLBACK_INSTANCE *instance, void *ctx )
+static void CALLBACK run_queue( TP_CALLBACK_INSTANCE *instance, void *ctx )
 {
-    struct request *request = ctx;
-    HANDLE handles[2];
+    struct queue *queue = ctx;
+    HANDLE handles[] = { queue->wait, queue->cancel };
 
-    handles[0] = request->task_wait;
-    handles[1] = request->task_cancel;
     for (;;)
     {
         DWORD err = WaitForMultipleObjects( 2, handles, FALSE, INFINITE );
@@ -150,21 +148,19 @@ static void CALLBACK task_proc( TP_CALLBACK_INSTANCE *instance, void *ctx )
         case WAIT_OBJECT_0:
         {
             struct task_header *task;
-            while ((task = dequeue_task( request )))
+            while ((task = dequeue_task( queue )))
             {
                 task->proc( task );
-                release_object( &task->request->hdr );
+                release_object( task->object );
                 heap_free( task );
             }
             break;
         }
         case WAIT_OBJECT_0 + 1:
             TRACE("exiting\n");
-            CloseHandle( request->task_cancel );
-            CloseHandle( request->task_wait );
-            request->task_cs.DebugInfo->Spare[0] = 0;
-            DeleteCriticalSection( &request->task_cs );
-            request->hdr.vtbl->destroy( &request->hdr );
+            CloseHandle( queue->wait );
+            CloseHandle( queue->cancel );
+            queue->object->vtbl->destroy( queue->object );
             return;
 
         default:
@@ -174,38 +170,43 @@ static void CALLBACK task_proc( TP_CALLBACK_INSTANCE *instance, void *ctx )
     }
 }
 
-static DWORD queue_task( struct task_header *task )
+static DWORD start_queue( struct object_header *object, struct queue *queue )
 {
-    struct request *request = task->request;
+    DWORD ret = ERROR_OUTOFMEMORY;
 
-    if (!request->task_wait)
+    if (queue->wait) return ERROR_SUCCESS;
+
+    queue->object = object;
+    list_init( &queue->tasks );
+    if (!(queue->wait = CreateEventW( NULL, FALSE, FALSE, NULL ))) goto error;
+    if (!(queue->cancel = CreateEventW( NULL, FALSE, FALSE, NULL ))) goto error;
+    if (!TrySubmitThreadpoolCallback( run_queue, queue, NULL )) ret = GetLastError();
+    else
     {
-        if (!(request->task_wait = CreateEventW( NULL, FALSE, FALSE, NULL ))) return ERROR_OUTOFMEMORY;
-        if (!(request->task_cancel = CreateEventW( NULL, FALSE, FALSE, NULL )))
-        {
-            CloseHandle( request->task_wait );
-            request->task_wait = NULL;
-            return ERROR_OUTOFMEMORY;
-        }
-        if (!TrySubmitThreadpoolCallback( task_proc, request, NULL ))
-        {
-            CloseHandle( request->task_wait );
-            request->task_wait = NULL;
-            CloseHandle( request->task_cancel );
-            request->task_cancel = NULL;
-            return GetLastError();
-        }
-        request->task_proc_running = TRUE;
-        InitializeCriticalSection( &request->task_cs );
-        request->task_cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": request.task_cs");
+        queue->proc_running = TRUE;
+        TRACE("started %p\n", queue);
+        return ERROR_SUCCESS;
     }
 
-    EnterCriticalSection( &request->task_cs );
-    TRACE("queueing task %p\n", task );
-    list_add_tail( &request->task_queue, &task->entry );
-    LeaveCriticalSection( &request->task_cs );
+error:
+    CloseHandle( queue->wait );
+    queue->wait = NULL;
+    CloseHandle( queue->cancel );
+    queue->cancel = NULL;
+    return ret;
+}
+
+static DWORD queue_task( struct object_header *object, struct queue *queue, struct task_header *task )
+{
+    DWORD ret;
+    if ((ret = start_queue( object, queue ))) return ret;
+
+    EnterCriticalSection( &queue->cs );
+    TRACE("queueing task %p in %p\n", task, queue);
+    list_add_tail( &queue->tasks, &task->entry );
+    LeaveCriticalSection( &queue->cs );
 
-    SetEvent( request->task_wait );
+    SetEvent( queue->wait );
     return ERROR_SUCCESS;
 }
 
@@ -2215,8 +2216,10 @@ static DWORD send_request( struct request *request, const WCHAR *headers, DWORD
 
 static void task_send_request( struct task_header *task )
 {
+    struct request *request = (struct request *)task->object;
     struct send_request *s = (struct send_request *)task;
-    send_request( s->hdr.request, s->headers, s->headers_len, s->optional, s->optional_len, s->total_len, s->context, TRUE );
+
+    send_request( request, s->headers, s->headers_len, s->optional, s->optional_len, s->total_len, s->context, TRUE );
     heap_free( s->headers );
 }
 
@@ -2250,8 +2253,8 @@ BOOL WINAPI WinHttpSendRequest( HINTERNET hrequest, LPCWSTR headers, DWORD heade
     {
         struct send_request *s;
 
-        if (!(s = heap_alloc( sizeof(struct send_request) ))) return FALSE;
-        s->hdr.request  = request;
+        if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
+        s->hdr.object   = &request->hdr;
         s->hdr.proc     = task_send_request;
         s->headers      = strdupW( headers );
         s->headers_len  = headers_len;
@@ -2261,10 +2264,9 @@ BOOL WINAPI WinHttpSendRequest( HINTERNET hrequest, LPCWSTR headers, DWORD heade
         s->context      = context;
 
         addref_object( &request->hdr );
-        ret = queue_task( (struct task_header *)s );
+        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)s );
     }
-    else
-        ret = send_request( request, headers, headers_len, optional, optional_len, total_len, context, FALSE );
+    else ret = send_request( request, headers, headers_len, optional, optional_len, total_len, context, FALSE );
 
     release_object( &request->hdr );
     SetLastError( ret );
@@ -2795,8 +2797,8 @@ static DWORD receive_response( struct request *request, BOOL async )
 
 static void task_receive_response( struct task_header *task )
 {
-    struct receive_response *r = (struct receive_response *)task;
-    receive_response( r->hdr.request, TRUE );
+    struct request *request = (struct request *)task->object;
+    receive_response( request, TRUE );
 }
 
 /***********************************************************************
@@ -2825,15 +2827,14 @@ BOOL WINAPI WinHttpReceiveResponse( HINTERNET hrequest, LPVOID reserved )
     {
         struct receive_response *r;
 
-        if (!(r = heap_alloc( sizeof(struct receive_response) ))) return FALSE;
-        r->hdr.request = request;
-        r->hdr.proc    = task_receive_response;
+        if (!(r = heap_alloc( sizeof(*r) ))) return FALSE;
+        r->hdr.object = &request->hdr;
+        r->hdr.proc   = task_receive_response;
 
         addref_object( &request->hdr );
-        ret = queue_task( (struct task_header *)r );
+        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)r );
     }
-    else
-        ret = receive_response( request, FALSE );
+    else ret = receive_response( request, FALSE );
 
     release_object( &request->hdr );
     SetLastError( ret );
@@ -2875,8 +2876,10 @@ static DWORD query_data_available( struct request *request, DWORD *available, BO
 
 static void task_query_data_available( struct task_header *task )
 {
+    struct request *request = (struct request *)task->object;
     struct query_data *q = (struct query_data *)task;
-    query_data_available( q->hdr.request, q->available, TRUE );
+
+    query_data_available( request, q->available, TRUE );
 }
 
 /***********************************************************************
@@ -2905,16 +2908,15 @@ BOOL WINAPI WinHttpQueryDataAvailable( HINTERNET hrequest, LPDWORD available )
     {
         struct query_data *q;
 
-        if (!(q = heap_alloc( sizeof(struct query_data) ))) return FALSE;
-        q->hdr.request = request;
-        q->hdr.proc    = task_query_data_available;
-        q->available   = available;
+        if (!(q = heap_alloc( sizeof(*q) ))) return FALSE;
+        q->hdr.object = &request->hdr;
+        q->hdr.proc   = task_query_data_available;
+        q->available  = available;
 
         addref_object( &request->hdr );
-        ret = queue_task( (struct task_header *)q );
+        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)q );
     }
-    else
-        ret = query_data_available( request, available, FALSE );
+    else ret = query_data_available( request, available, FALSE );
 
     release_object( &request->hdr );
     SetLastError( ret );
@@ -2923,8 +2925,10 @@ BOOL WINAPI WinHttpQueryDataAvailable( HINTERNET hrequest, LPDWORD available )
 
 static void task_read_data( struct task_header *task )
 {
+    struct request *request = (struct request *)task->object;
     struct read_data *r = (struct read_data *)task;
-    read_data( r->hdr.request, r->buffer, r->to_read, r->read, TRUE );
+
+    read_data( request, r->buffer, r->to_read, r->read, TRUE );
 }
 
 /***********************************************************************
@@ -2953,18 +2957,17 @@ BOOL WINAPI WinHttpReadData( HINTERNET hrequest, LPVOID buffer, DWORD to_read, L
     {
         struct read_data *r;
 
-        if (!(r = heap_alloc( sizeof(struct read_data) ))) return FALSE;
-        r->hdr.request = request;
-        r->hdr.proc    = task_read_data;
-        r->buffer      = buffer;
-        r->to_read     = to_read;
-        r->read        = read;
+        if (!(r = heap_alloc( sizeof(*r) ))) return FALSE;
+        r->hdr.object = &request->hdr;
+        r->hdr.proc   = task_read_data;
+        r->buffer     = buffer;
+        r->to_read    = to_read;
+        r->read       = read;
 
         addref_object( &request->hdr );
-        ret = queue_task( (struct task_header *)r );
+        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)r );
     }
-    else
-        ret = read_data( request, buffer, to_read, read, FALSE );
+    else ret = read_data( request, buffer, to_read, read, FALSE );
 
     release_object( &request->hdr );
     SetLastError( ret );
@@ -2995,8 +2998,10 @@ static DWORD write_data( struct request *request, const void *buffer, DWORD to_w
 
 static void task_write_data( struct task_header *task )
 {
+    struct request *request = (struct request *)task->object;
     struct write_data *w = (struct write_data *)task;
-    write_data( w->hdr.request, w->buffer, w->to_write, w->written, TRUE );
+
+    write_data( request, w->buffer, w->to_write, w->written, TRUE );
 }
 
 /***********************************************************************
@@ -3025,18 +3030,17 @@ BOOL WINAPI WinHttpWriteData( HINTERNET hrequest, LPCVOID buffer, DWORD to_write
     {
         struct write_data *w;
 
-        if (!(w = heap_alloc( sizeof(struct write_data) ))) return FALSE;
-        w->hdr.request = request;
-        w->hdr.proc    = task_write_data;
-        w->buffer      = buffer;
-        w->to_write    = to_write;
-        w->written     = written;
+        if (!(w = heap_alloc( sizeof(*w) ))) return FALSE;
+        w->hdr.object = &request->hdr;
+        w->hdr.proc   = task_write_data;
+        w->buffer     = buffer;
+        w->to_write   = to_write;
+        w->written    = written;
 
         addref_object( &request->hdr );
-        ret = queue_task( (struct task_header *)w );
+        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)w );
     }
-    else
-        ret = write_data( request, buffer, to_write, written, FALSE );
+    else ret = write_data( request, buffer, to_write, written, FALSE );
 
     release_object( &request->hdr );
     SetLastError( ret );
diff --git a/dlls/winhttp/session.c b/dlls/winhttp/session.c
index a5ec8b22f39..186b70e4a2d 100644
--- a/dlls/winhttp/session.c
+++ b/dlls/winhttp/session.c
@@ -578,11 +578,11 @@ static void request_destroy( struct object_header *hdr )
 
     TRACE("%p\n", request);
 
-    if (request->task_proc_running)
+    if (request->queue.proc_running)
     {
         /* Signal to the task proc to quit. It will call this again when it does. */
-        request->task_proc_running = FALSE;
-        SetEvent( request->task_cancel );
+        request->queue.proc_running = FALSE;
+        SetEvent( request->queue.cancel );
         return;
     }
     release_object( &request->connect->hdr );
@@ -613,6 +613,9 @@ static void request_destroy( struct object_header *hdr )
             heap_free( request->creds[i][j].password );
         }
     }
+
+    request->queue.cs.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection( &request->queue.cs );
     heap_free( request );
 }
 
@@ -1117,7 +1120,8 @@ HINTERNET WINAPI WinHttpOpenRequest( HINTERNET hconnect, LPCWSTR verb, LPCWSTR o
     request->hdr.notify_mask = connect->hdr.notify_mask;
     request->hdr.context = connect->hdr.context;
     request->hdr.redirect_policy = connect->hdr.redirect_policy;
-    list_init( &request->task_queue );
+    InitializeCriticalSection( &request->queue.cs );
+    request->queue.cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": request.queue.cs");
 
     addref_object( &connect->hdr );
     request->connect = connect;
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 9b07b64b090..207696e674d 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -155,6 +155,16 @@ struct authinfo
     BOOL finished; /* finished authenticating */
 };
 
+struct queue
+{
+    struct object_header *object;
+    CRITICAL_SECTION cs;
+    BOOL proc_running;
+    HANDLE wait;
+    HANDLE cancel;
+    struct list tasks;
+};
+
 enum request_flags
 {
     REQUEST_FLAG_WEBSOCKET_UPGRADE = 0x01,
@@ -196,11 +206,7 @@ struct request
     DWORD num_headers;
     struct authinfo *authinfo;
     struct authinfo *proxy_authinfo;
-    HANDLE task_wait;
-    HANDLE task_cancel;
-    BOOL   task_proc_running;
-    struct list task_queue;
-    CRITICAL_SECTION task_cs;
+    struct queue queue;
     struct
     {
         WCHAR *username;
@@ -217,7 +223,7 @@ struct socket
 struct task_header
 {
     struct list entry;
-    struct request *request;
+    struct object_header *object;
     void (*proc)( struct task_header * );
 };
 
From 57a1936053380de95c247d81619c5dc7bf73086d Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 22 Jun 2020 21:39:23 +0200
Subject: [PATCH] winhttp: Pass length in
 WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER callback.

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 9b72253a260..3129d4154ec 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -1592,7 +1592,8 @@ static DWORD open_connection( struct request *request )
 
         TRACE("connecting to %s:%u\n", debugstr_w(addressW), port);
 
-        send_callback( &request->hdr, WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER, addressW, 0 );
+        len = lstrlenW( addressW ) + 1;
+        send_callback( &request->hdr, WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER, addressW, len );
 
         if ((ret = netconn_create( host, &connect->sockaddr, request->connect_timeout, &netconn )))
         {
From c8c0bc6d2e428129886bbecf9881645f3666b16f Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 22 Jun 2020 21:39:24 +0200
Subject: [PATCH] winhttp: Set socket notification mask and callback from the
 parent request.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 3129d4154ec..d44baa26c2c 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3106,6 +3106,8 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
     socket->hdr.type = WINHTTP_HANDLE_TYPE_SOCKET;
     socket->hdr.vtbl = &socket_vtbl;
     socket->hdr.refs = 1;
+    socket->hdr.callback = request->hdr.callback;
+    socket->hdr.notify_mask = request->hdr.notify_mask;
     socket->hdr.context = context;
 
     addref_object( &request->hdr );
From cc1c4759bacace8a8d1060e8b0e20dce592accd3 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 22 Jun 2020 21:39:25 +0200
Subject: [PATCH] winhttp: Send WINHTTP_CALLBACK_STATUS_HANDLE_CREATED
 notification in WinHttpWebSocketCompleteUpgrade.

Based on a patch by Alistair Leslie-Hughes.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index d44baa26c2c..0c038289f85 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3113,7 +3113,10 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
     addref_object( &request->hdr );
     socket->request = request;
 
-    hsocket = alloc_handle( &socket->hdr );
+    if ((hsocket = alloc_handle( &socket->hdr )))
+    {
+        send_callback( &request->hdr, WINHTTP_CALLBACK_STATUS_HANDLE_CREATED, &hsocket, sizeof(hsocket) );
+    }
 
     release_object( &socket->hdr );
     release_object( &request->hdr );

From 68b44e305504c5e0fa8e9917478df96f8a08b62f Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 24 Jun 2020 10:33:03 +0200
Subject: [PATCH] winhttp: Implement WinHttpWebSocketSend.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 184 ++++++++++++++++++++++++++++++++-
 dlls/winhttp/winhttp_private.h |  17 +++
 2 files changed, 199 insertions(+), 2 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 0c038289f85..9ac3c6e89ed 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3061,7 +3061,16 @@ static void socket_destroy( struct object_header *hdr )
 
     TRACE("%p\n", socket);
 
+    if (socket->send_q.proc_running)
+    {
+        socket->send_q.proc_running = FALSE;
+        SetEvent( socket->send_q.cancel );
+        return;
+    }
     release_object( &socket->request->hdr );
+
+    socket->send_q.cs.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection( &socket->send_q.cs );
     heap_free( socket );
 }
 
@@ -3109,6 +3118,8 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
     socket->hdr.callback = request->hdr.callback;
     socket->hdr.notify_mask = request->hdr.notify_mask;
     socket->hdr.context = context;
+    InitializeCriticalSection( &socket->send_q.cs );
+    socket->send_q.cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": socket.send_q.cs");
 
     addref_object( &request->hdr );
     socket->request = request;
@@ -3125,10 +3136,179 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
     return hsocket;
 }
 
+static DWORD send_bytes( struct netconn *netconn, char *bytes, int len )
+{
+    int count;
+    DWORD err;
+    if ((err = netconn_send( netconn, bytes, len, &count ))) return err;
+    return (count == len) ? ERROR_SUCCESS : ERROR_INTERNAL_ERROR;
+}
+
+/* rfc6455 */
+enum opcode
+{
+    OPCODE_CONTINUE  = 0x00,
+    OPCODE_TEXT      = 0x01,
+    OPCODE_BINARY    = 0x02,
+    OPCODE_RESERVED3 = 0x03,
+    OPCODE_RESERVED4 = 0x04,
+    OPCODE_RESERVED5 = 0x05,
+    OPCODE_RESERVED6 = 0x06,
+    OPCODE_RESERVED7 = 0x07,
+    OPCODE_CLOSE     = 0x08,
+    OPCODE_PING      = 0x09,
+    OPCODE_PONG      = 0x0a,
+    OPCODE_INVALID   = 0xff,
+};
+
+static enum opcode map_buffer_type( WINHTTP_WEB_SOCKET_BUFFER_TYPE type )
+{
+    switch (type)
+    {
+    case WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE:   return OPCODE_TEXT;
+    case WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE: return OPCODE_BINARY;
+    case WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE:          return OPCODE_CLOSE;
+    default:
+        FIXME("buffer type %u not supported\n", type);
+        return OPCODE_INVALID;
+    }
+}
+
+#define FIN_BIT (1 << 7)
+#define MASK_BIT (1 << 7)
+#define RESERVED_BIT (7 << 4)
+
+static DWORD send_frame( struct netconn *netconn, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, USHORT status, const char *buf,
+                         DWORD buflen, BOOL final )
+{
+    DWORD i = 0, j, ret, offset = 2, len = buflen;
+    enum opcode opcode = map_buffer_type( type );
+    char hdr[14], byte, *mask;
+
+    if (opcode == OPCODE_CLOSE) len += sizeof(status);
+
+    hdr[0] = final ? (char)FIN_BIT : 0;
+    hdr[0] |= opcode;
+    hdr[1] = (char)MASK_BIT;
+    if (len < 126) hdr[1] |= len;
+    else if (len < 65536)
+    {
+        hdr[1] |= 126;
+        hdr[2] = len >> 8;
+        hdr[3] = len & 0xff;
+        offset += 2;
+    }
+    else
+    {
+        hdr[1] |= 127;
+        hdr[2] = hdr[3] = hdr[4] = hdr[5] = 0;
+        hdr[6] = len >> 24;
+        hdr[7] = (len >> 16) & 0xff;
+        hdr[8] = (len >> 8) & 0xff;
+        hdr[9] = len & 0xff;
+        offset += 8;
+    }
+    mask = &hdr[offset];
+    RtlGenRandom( mask, 4 );
+    if ((ret = send_bytes( netconn, hdr, offset + 4 ))) return ret;
+
+    if (opcode == OPCODE_CLOSE) /* prepend status code */
+    {
+        byte = (status >> 8) ^ mask[i++ % 4];
+        if ((ret = send_bytes( netconn, &byte, 1 ))) return ret;
+
+        byte = (status & 0xff) ^ mask[i++ % 4];
+        if ((ret = send_bytes( netconn, &byte, 1 ))) return ret;
+    }
+
+    for (j = 0; j < buflen; j++)
+    {
+        byte = buf[j] ^ mask[i++ % 4];
+        if ((ret = send_bytes( netconn, &byte, 1 ))) return ret;
+    }
+
+    return ERROR_SUCCESS;
+}
+
+static DWORD socket_send( struct socket *socket, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, const void *buf, DWORD len,
+                          BOOL async )
+{
+    DWORD ret;
+
+    ret = send_frame( socket->request->netconn, type, 0, buf, len, TRUE );
+    if (async)
+    {
+        if (!ret)
+        {
+            WINHTTP_WEB_SOCKET_STATUS status;
+            status.dwBytesTransferred = len;
+            status.eBufferType        = type;
+            send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE, &status, sizeof(status) );
+        }
+        else
+        {
+            WINHTTP_WEB_SOCKET_ASYNC_RESULT result;
+            result.AsyncResult.dwResult = API_WRITE_DATA;
+            result.AsyncResult.dwError  = ret;
+            result.Operation = WINHTTP_WEB_SOCKET_SEND_OPERATION;
+            send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_REQUEST_ERROR, &result, sizeof(result) );
+        }
+    }
+    return ret;
+}
+
+static void task_socket_send( struct task_header *task )
+{
+    struct socket *socket = (struct socket *)task->object;
+    struct socket_send *s = (struct socket_send *)task;
+
+    socket_send( socket, s->type, s->buf, s->len, TRUE );
+}
+
 DWORD WINAPI WinHttpWebSocketSend( HINTERNET hsocket, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, void *buf, DWORD len )
 {
-    FIXME("%p, %u, %p, %u\n", hsocket, type, buf, len);
-    return ERROR_INVALID_PARAMETER;
+    struct socket *socket;
+    DWORD ret;
+
+    TRACE("%p, %u, %p, %u\n", hsocket, type, buf, len);
+
+    if (len && !buf) return ERROR_INVALID_PARAMETER;
+    if (type != WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE && type != WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE)
+    {
+        FIXME("buffer type %u not supported\n", type);
+        return ERROR_NOT_SUPPORTED;
+    }
+
+    if (!(socket = (struct socket *)grab_object( hsocket ))) return ERROR_INVALID_HANDLE;
+    if (socket->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
+    {
+        release_object( &socket->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
+    }
+    if (socket->state != SOCKET_STATE_OPEN)
+    {
+        release_object( &socket->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
+    }
+
+    if (socket->request->connect->hdr.flags & WINHTTP_FLAG_ASYNC)
+    {
+        struct socket_send *s;
+
+        if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
+        s->hdr.object = &socket->hdr;
+        s->hdr.proc   = task_socket_send;
+        s->type       = type;
+        s->buf        = buf;
+        s->len        = len;
+
+        addref_object( &socket->hdr );
+        ret = queue_task( &socket->hdr, &socket->send_q, (struct task_header *)s );
+    }
+    else ret = socket_send( socket, type, buf, len, FALSE );
+
+    release_object( &socket->hdr );
+    return ret;
 }
 
 DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, DWORD *read,
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 207696e674d..d9e99651abe 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -214,10 +214,19 @@ struct request
     } creds[TARGET_MAX][SCHEME_MAX];
 };
 
+enum socket_state
+{
+    SOCKET_STATE_OPEN     = 0,
+    SOCKET_STATE_SHUTDOWN = 1,
+    SOCKET_STATE_CLOSED   = 2,
+};
+
 struct socket
 {
     struct object_header hdr;
     struct request *request;
+    enum socket_state state;
+    struct queue send_q;
 };
 
 struct task_header
@@ -265,6 +274,14 @@ struct write_data
     DWORD *written;
 };
 
+struct socket_send
+{
+    struct task_header hdr;
+    WINHTTP_WEB_SOCKET_BUFFER_TYPE type;
+    const void *buf;
+    DWORD len;
+};
+
 struct object_header *addref_object( struct object_header * ) DECLSPEC_HIDDEN;
 struct object_header *grab_object( HINTERNET ) DECLSPEC_HIDDEN;
 void release_object( struct object_header * ) DECLSPEC_HIDDEN;
From f18cbfcd5d1ce72b9869f35bb5bd81ea0e5ea8d7 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 24 Jun 2020 10:33:04 +0200
Subject: [PATCH] winhttp: Implement WinHttpWebSocketReceive.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 159 ++++++++++++++++++++++++++++++++-
 dlls/winhttp/winhttp_private.h |  10 +++
 2 files changed, 165 insertions(+), 4 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 9ac3c6e89ed..e6dd6d9068c 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -34,6 +34,7 @@
 #include "schannel.h"
 #include "winhttp.h"
 #include "ntsecapi.h"
+#include "winternl.h"
 
 #include "wine/debug.h"
 #include "winhttp_private.h"
@@ -3067,10 +3068,19 @@ static void socket_destroy( struct object_header *hdr )
         SetEvent( socket->send_q.cancel );
         return;
     }
+    if (socket->recv_q.proc_running)
+    {
+        socket->recv_q.proc_running = FALSE;
+        SetEvent( socket->recv_q.cancel );
+        return;
+    }
     release_object( &socket->request->hdr );
 
     socket->send_q.cs.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection( &socket->send_q.cs );
+
+    socket->recv_q.cs.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection( &socket->recv_q.cs );
     heap_free( socket );
 }
 
@@ -3120,6 +3130,8 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
     socket->hdr.context = context;
     InitializeCriticalSection( &socket->send_q.cs );
     socket->send_q.cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": socket.send_q.cs");
+    InitializeCriticalSection( &socket->recv_q.cs );
+    socket->recv_q.cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": socket.recv_q.cs");
 
     addref_object( &request->hdr );
     socket->request = request;
@@ -3311,11 +3323,150 @@ DWORD WINAPI WinHttpWebSocketSend( HINTERNET hsocket, WINHTTP_WEB_SOCKET_BUFFER_
     return ret;
 }
 
-DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, DWORD *read,
-                                      WINHTTP_WEB_SOCKET_BUFFER_TYPE *type )
+static DWORD receive_bytes( struct netconn *netconn, char *buf, DWORD len, DWORD *ret_len )
 {
-    FIXME("%p, %p, %u, %p, %p\n", hsocket, buf, len, read, type);
-    return ERROR_INVALID_PARAMETER;
+    DWORD err;
+    if ((err = netconn_recv( netconn, buf, len, 0, (int *)ret_len ))) return err;
+    if (len && !*ret_len) return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
+    return ERROR_SUCCESS;
+}
+
+static WINHTTP_WEB_SOCKET_BUFFER_TYPE map_opcode( enum opcode opcode )
+{
+    switch (opcode)
+    {
+    case OPCODE_TEXT:   return WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE;
+    case OPCODE_BINARY: return WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE;
+    case OPCODE_CLOSE:  return WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE;
+    default:
+        ERR("opcode %u not handled\n", opcode);
+        return ~0u;
+    }
+}
+
+static DWORD receive_frame( struct netconn *netconn, DWORD *ret_len, WINHTTP_WEB_SOCKET_BUFFER_TYPE *ret_type )
+{
+    WINHTTP_WEB_SOCKET_BUFFER_TYPE type;
+    DWORD ret, len, count;
+    enum opcode opcode;
+    char hdr[2];
+
+    if ((ret = receive_bytes( netconn, hdr, sizeof(hdr), &count ))) return ret;
+    if (count != sizeof(hdr) || (hdr[0] & RESERVED_BIT) || (hdr[1] & MASK_BIT))
+    {
+        return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
+    }
+
+    opcode = hdr[0] & 0xf;
+    type = map_opcode( opcode );
+
+    len = hdr[1] & ~MASK_BIT;
+    if (len == 126)
+    {
+        USHORT len16;
+        if ((ret = receive_bytes( netconn, (char *)&len16, sizeof(len16), &count ))) return ret;
+        if (count != sizeof(len16)) return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
+        len = RtlUshortByteSwap( len16 );
+    }
+    else if (len == 127)
+    {
+        ULONGLONG len64;
+        if ((ret = receive_bytes( netconn, (char *)&len64, sizeof(len64), &count ))) return ret;
+        if (count != sizeof(len64)) return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
+        if ((len64 = RtlUlonglongByteSwap( len64 )) > ~0u) return ERROR_NOT_SUPPORTED;
+        len = len64;
+    }
+
+    *ret_len = len;
+    *ret_type = type;
+    return ERROR_SUCCESS;
+}
+
+static DWORD socket_receive( struct socket *socket, void *buf, DWORD len, DWORD *ret_len,
+                             WINHTTP_WEB_SOCKET_BUFFER_TYPE *ret_type, BOOL async )
+{
+    DWORD count, ret = ERROR_SUCCESS;
+
+    if (!socket->read_size) ret = receive_frame( socket->request->netconn, &socket->read_size, &socket->buf_type );
+    if (!ret) ret = receive_bytes( socket->request->netconn, buf, min(len, socket->read_size), &count );
+    if (!ret)
+    {
+        socket->read_size -= count;
+        if (!async)
+        {
+            *ret_len = count;
+            *ret_type = socket->buf_type;
+        }
+    }
+
+    if (async)
+    {
+        if (!ret)
+        {
+            WINHTTP_WEB_SOCKET_STATUS status;
+            status.dwBytesTransferred = count;
+            status.eBufferType        = socket->buf_type;
+            send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_READ_COMPLETE, &status, sizeof(status) );
+        }
+        else
+        {
+            WINHTTP_WEB_SOCKET_ASYNC_RESULT result;
+            result.AsyncResult.dwResult = API_READ_DATA;
+            result.AsyncResult.dwError  = ret;
+            result.Operation = WINHTTP_WEB_SOCKET_RECEIVE_OPERATION;
+            send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_REQUEST_ERROR, &result, sizeof(result) );
+        }
+    }
+    return ret;
+}
+
+static void task_socket_receive( struct task_header *task )
+{
+    struct socket *socket = (struct socket *)task->object;
+    struct socket_receive *r = (struct socket_receive *)task;
+
+    socket_receive( socket, r->buf, r->len, NULL, NULL, TRUE );
+}
+
+DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, DWORD *ret_len,
+                                      WINHTTP_WEB_SOCKET_BUFFER_TYPE *ret_type )
+{
+    struct socket *socket;
+    DWORD ret;
+
+    TRACE("%p, %p, %u, %p, %p\n", hsocket, buf, len, ret_len, ret_type);
+
+    if (!buf || !len) return ERROR_INVALID_PARAMETER;
+
+    if (!(socket = (struct socket *)grab_object( hsocket ))) return ERROR_INVALID_HANDLE;
+    if (socket->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
+    {
+        release_object( &socket->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
+    }
+    if (socket->state != SOCKET_STATE_OPEN)
+    {
+        release_object( &socket->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
+    }
+
+    if (socket->request->connect->hdr.flags & WINHTTP_FLAG_ASYNC)
+    {
+        struct socket_receive *r;
+
+        if (!(r = heap_alloc( sizeof(*r) ))) return FALSE;
+        r->hdr.object = &socket->hdr;
+        r->hdr.proc   = task_socket_receive;
+        r->buf        = buf;
+        r->len        = len;
+
+        addref_object( &socket->hdr );
+        ret = queue_task( &socket->hdr, &socket->recv_q, (struct task_header *)r );
+    }
+    else ret = socket_receive( socket, buf, len, ret_len, ret_type, FALSE );
+
+    release_object( &socket->hdr );
+    return ret;
 }
 
 DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index d9e99651abe..9cf9c396cb0 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -227,6 +227,9 @@ struct socket
     struct request *request;
     enum socket_state state;
     struct queue send_q;
+    struct queue recv_q;
+    WINHTTP_WEB_SOCKET_BUFFER_TYPE buf_type;
+    DWORD read_size;
 };
 
 struct task_header
@@ -282,6 +285,13 @@ struct socket_send
     DWORD len;
 };
 
+struct socket_receive
+{
+    struct task_header hdr;
+    void *buf;
+    DWORD len;
+};
+
 struct object_header *addref_object( struct object_header * ) DECLSPEC_HIDDEN;
 struct object_header *grab_object( HINTERNET ) DECLSPEC_HIDDEN;
 void release_object( struct object_header * ) DECLSPEC_HIDDEN;
From da0515c165826be545ec79c728271bf6b6727f24 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 24 Jun 2020 10:33:05 +0200
Subject: [PATCH] winhttp: Implement WinHttpWebSocketShutdown.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 69 +++++++++++++++++++++++++++++++++-
 dlls/winhttp/winhttp_private.h |  8 ++++
 2 files changed, 75 insertions(+), 2 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index e6dd6d9068c..c5abfdb8e49 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3469,10 +3469,75 @@ DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, D
     return ret;
 }
 
+static DWORD socket_shutdown( struct socket *socket, USHORT status, const void *reason, DWORD len, BOOL async )
+{
+    DWORD ret;
+
+    ret = send_frame( socket->request->netconn, WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE, status, reason, len, TRUE );
+    if (async)
+    {
+        if (!ret) send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_SHUTDOWN_COMPLETE, NULL, 0 );
+        else
+        {
+            WINHTTP_WEB_SOCKET_ASYNC_RESULT result;
+            result.AsyncResult.dwResult = API_WRITE_DATA;
+            result.AsyncResult.dwError  = ret;
+            result.Operation = WINHTTP_WEB_SOCKET_SHUTDOWN_OPERATION;
+            send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_REQUEST_ERROR, &result, sizeof(result) );
+        }
+    }
+
+    if (!ret) socket->state = SOCKET_STATE_SHUTDOWN;
+    return ret;
+}
+
+static void task_socket_shutdown( struct task_header *task )
+{
+    struct socket *socket = (struct socket *)task->object;
+    struct socket_shutdown *s = (struct socket_shutdown *)task;
+
+    socket_shutdown( socket, s->status, s->reason, s->len, TRUE );
+}
+
 DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
 {
-    FIXME("%p, %u, %p, %u\n", hsocket, status, reason, len);
-    return ERROR_INVALID_PARAMETER;
+    struct socket *socket;
+    DWORD ret;
+
+    TRACE("%p, %u, %p, %u\n", hsocket, status, reason, len);
+
+    if (len && !reason) return ERROR_INVALID_PARAMETER;
+
+    if (!(socket = (struct socket *)grab_object( hsocket ))) return ERROR_INVALID_HANDLE;
+    if (socket->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
+    {
+        release_object( &socket->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
+    }
+    if (socket->state >= SOCKET_STATE_SHUTDOWN)
+    {
+        release_object( &socket->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
+    }
+
+    if (socket->request->connect->hdr.flags & WINHTTP_FLAG_ASYNC)
+    {
+        struct socket_shutdown *s;
+
+        if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
+        s->hdr.object = &socket->hdr;
+        s->hdr.proc   = task_socket_shutdown;
+        s->status     = status;
+        s->reason     = reason;
+        s->len        = len;
+
+        addref_object( &socket->hdr );
+        ret = queue_task( &socket->hdr, &socket->send_q, (struct task_header *)s );
+    }
+    else ret = socket_shutdown( socket, status, reason, len, FALSE );
+
+    release_object( &socket->hdr );
+    return ret;
 }
 
 DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 9cf9c396cb0..7d81e359344 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -292,6 +292,14 @@ struct socket_receive
     DWORD len;
 };
 
+struct socket_shutdown
+{
+    struct task_header hdr;
+    USHORT status;
+    const void *reason;
+    DWORD len;
+};
+
 struct object_header *addref_object( struct object_header * ) DECLSPEC_HIDDEN;
 struct object_header *grab_object( HINTERNET ) DECLSPEC_HIDDEN;
 void release_object( struct object_header * ) DECLSPEC_HIDDEN;
From 61ea74b457dc25e5f2a3b824aa9b4a1c0d2f6a01 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 24 Jun 2020 10:33:06 +0200
Subject: [PATCH] winhttp: Implement WinHttpWebSocketClose.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 99 +++++++++++++++++++++++++++++++++-
 dlls/winhttp/winhttp_private.h |  3 ++
 2 files changed, 100 insertions(+), 2 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index c5abfdb8e49..60a9585d0d8 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3540,10 +3540,105 @@ DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *r
     return ret;
 }
 
+static DWORD socket_close( struct socket *socket, USHORT status, const void *reason, DWORD len, BOOL async )
+{
+    struct netconn *netconn = socket->request->netconn;
+    DWORD ret, count;
+
+    while (socket->read_size) /* drain any pending data */
+    {
+        char buf[1024];
+        if ((ret = receive_bytes( netconn, buf, min(socket->read_size, sizeof(buf)), &count ))) goto done;
+        socket->read_size -= count;
+    }
+
+    if (socket->state < SOCKET_STATE_SHUTDOWN)
+    {
+        if ((ret = send_frame( netconn, WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE, status, reason, len, TRUE ))) goto done;
+        socket->state = SOCKET_STATE_SHUTDOWN;
+    }
+
+    if ((ret = receive_frame( netconn, &count, &socket->buf_type ))) goto done;
+    if (socket->buf_type != WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE || (count && count > sizeof(socket->reason)))
+    {
+        ret = ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
+        goto done;
+    }
+
+    if ((ret = receive_bytes( netconn, (char *)&socket->status, sizeof(socket->status), &count ))) goto done;
+    if (count != sizeof(socket->status))
+    {
+        ret = ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
+        goto done;
+    }
+    socket->status = RtlUshortByteSwap( socket->status );
+    ret = receive_bytes( netconn, socket->reason, sizeof(socket->reason), &socket->reason_len );
+
+done:
+    if (async)
+    {
+        if (!ret) send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_CLOSE_COMPLETE, NULL, 0 );
+        else
+        {
+            WINHTTP_WEB_SOCKET_ASYNC_RESULT result;
+            result.AsyncResult.dwResult = API_READ_DATA; /* FIXME */
+            result.AsyncResult.dwError  = ret;
+            result.Operation = WINHTTP_WEB_SOCKET_CLOSE_OPERATION;
+            send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_REQUEST_ERROR, &result, sizeof(result) );
+        }
+    }
+
+    if (!ret) socket->state = SOCKET_STATE_CLOSED;
+    return ret;
+}
+
+static void task_socket_close( struct task_header *task )
+{
+    struct socket *socket = (struct socket *)task->object;
+    struct socket_shutdown *s = (struct socket_shutdown *)task;
+
+    socket_close( socket, s->status, s->reason, s->len, TRUE );
+}
+
 DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
 {
-    FIXME("%p, %u, %p, %u\n", hsocket, status, reason, len);
-    return ERROR_INVALID_PARAMETER;
+    struct socket *socket;
+    DWORD ret;
+
+    TRACE("%p, %u, %p, %u\n", hsocket, status, reason, len);
+
+    if (len && !reason) return ERROR_INVALID_PARAMETER;
+
+    if (!(socket = (struct socket *)grab_object( hsocket ))) return ERROR_INVALID_HANDLE;
+    if (socket->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
+    {
+        release_object( &socket->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
+    }
+    if (socket->state >= SOCKET_STATE_CLOSED)
+    {
+        release_object( &socket->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
+    }
+
+    if (socket->request->connect->hdr.flags & WINHTTP_FLAG_ASYNC)
+    {
+        struct socket_shutdown *s;
+
+        if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
+        s->hdr.object = &socket->hdr;
+        s->hdr.proc   = task_socket_close;
+        s->status     = status;
+        s->reason     = reason;
+        s->len        = len;
+
+        addref_object( &socket->hdr );
+        ret = queue_task( &socket->hdr, &socket->recv_q, (struct task_header *)s );
+    }
+    else ret = socket_close( socket, status, reason, len, FALSE );
+
+    release_object( &socket->hdr );
+    return ret;
 }
 
 DWORD WINAPI WinHttpWebSocketQueryCloseStatus( HINTERNET hsocket, USHORT *status, void *reason, DWORD len,
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 7d81e359344..41ada14c0ce 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -230,6 +230,9 @@ struct socket
     struct queue recv_q;
     WINHTTP_WEB_SOCKET_BUFFER_TYPE buf_type;
     DWORD read_size;
+    USHORT status;
+    char reason[128];
+    DWORD reason_len;
 };
 
 struct task_header
From 3b1d18fd6e61e5d27bc2b45c92bae58874626908 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 24 Jun 2020 10:33:07 +0200
Subject: [PATCH] winhttp: Implement WinHttpWebSocketQueryCloseStatus.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c | 34 +++++++++++++++++++++++++++++++---
 1 file changed, 31 insertions(+), 3 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 60a9585d0d8..631fbb004f1 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3642,10 +3642,38 @@ DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reas
 }
 
 DWORD WINAPI WinHttpWebSocketQueryCloseStatus( HINTERNET hsocket, USHORT *status, void *reason, DWORD len,
-                                               DWORD *consumed )
+                                               DWORD *ret_len )
 {
-    FIXME("%p, %p, %p, %u, %p\n", hsocket, status, reason, len, consumed);
-    return ERROR_INVALID_PARAMETER;
+    struct socket *socket;
+    DWORD ret;
+
+    TRACE("%p, %p, %p, %u, %p\n", hsocket, status, reason, len, ret_len);
+
+    if (!status || (len && !reason) || !ret_len) return ERROR_INVALID_PARAMETER;
+
+    if (!(socket = (struct socket *)grab_object( hsocket ))) return ERROR_INVALID_HANDLE;
+    if (socket->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
+    {
+        release_object( &socket->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
+    }
+    if (socket->state < SOCKET_STATE_CLOSED)
+    {
+        release_object( &socket->hdr );
+        return ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
+    }
+
+    *status = socket->status;
+    *ret_len = socket->reason_len;
+    if (socket->reason_len > len) ret = ERROR_INSUFFICIENT_BUFFER;
+    else
+    {
+        memcpy( reason, socket->reason, socket->reason_len );
+        ret = ERROR_SUCCESS;
+    }
+
+    release_object( &socket->hdr );
+    return ret;
 }
 
 enum request_state
From 938b3e5771671795397d94a84f14151e5fa390cd Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 24 Jun 2020 10:33:08 +0200
Subject: [PATCH] winhttp/tests: Add asynchronous WebSocket tests.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/tests/notification.c | 206 ++++++++++++++++++++++++++++++
 1 file changed, 206 insertions(+)

diff --git a/dlls/winhttp/tests/notification.c b/dlls/winhttp/tests/notification.c
index 435e262d18b..98e4024867f 100644
--- a/dlls/winhttp/tests/notification.c
+++ b/dlls/winhttp/tests/notification.c
@@ -28,12 +28,24 @@
 
 #include "wine/test.h"
 
+static DWORD (WINAPI *pWinHttpWebSocketClose)(HINTERNET,USHORT,void*,DWORD);
+static HINTERNET (WINAPI *pWinHttpWebSocketCompleteUpgrade)(HINTERNET,DWORD_PTR);
+static DWORD (WINAPI *pWinHttpWebSocketQueryCloseStatus)(HINTERNET,USHORT*,void*,DWORD,DWORD*);
+static DWORD (WINAPI *pWinHttpWebSocketReceive)(HINTERNET,void*,DWORD,DWORD*,WINHTTP_WEB_SOCKET_BUFFER_TYPE*);
+static DWORD (WINAPI *pWinHttpWebSocketSend)(HINTERNET,WINHTTP_WEB_SOCKET_BUFFER_TYPE,void*,DWORD);
+static DWORD (WINAPI *pWinHttpWebSocketShutdown)(HINTERNET,USHORT,void*,DWORD);
+
 enum api
 {
     winhttp_connect = 1,
     winhttp_open_request,
     winhttp_send_request,
     winhttp_receive_response,
+    winhttp_websocket_complete_upgrade,
+    winhttp_websocket_send,
+    winhttp_websocket_receive,
+    winhttp_websocket_shutdown,
+    winhttp_websocket_close,
     winhttp_query_data,
     winhttp_read_data,
     winhttp_write_data,
@@ -615,6 +627,191 @@ static void test_async( void )
     end_test( &info, __LINE__ );
 }
 
+static const struct notification websocket_test[] =
+{
+    { winhttp_connect,                    WINHTTP_CALLBACK_STATUS_HANDLE_CREATED },
+    { winhttp_open_request,               WINHTTP_CALLBACK_STATUS_HANDLE_CREATED },
+    { winhttp_send_request,               WINHTTP_CALLBACK_STATUS_RESOLVING_NAME },
+    { winhttp_send_request,               WINHTTP_CALLBACK_STATUS_NAME_RESOLVED },
+    { winhttp_send_request,               WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER },
+    { winhttp_send_request,               WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER },
+    { winhttp_send_request,               WINHTTP_CALLBACK_STATUS_SENDING_REQUEST },
+    { winhttp_send_request,               WINHTTP_CALLBACK_STATUS_REQUEST_SENT },
+    { winhttp_send_request,               WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE, NF_SIGNAL },
+    { winhttp_receive_response,           WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE },
+    { winhttp_receive_response,           WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED },
+    { winhttp_receive_response,           WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE, NF_SIGNAL },
+    { winhttp_websocket_complete_upgrade, WINHTTP_CALLBACK_STATUS_HANDLE_CREATED, NF_SIGNAL },
+    { winhttp_websocket_send,             WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE, NF_SIGNAL },
+    { winhttp_websocket_receive,          WINHTTP_CALLBACK_STATUS_READ_COMPLETE, NF_SIGNAL },
+    { winhttp_websocket_shutdown,         WINHTTP_CALLBACK_STATUS_SHUTDOWN_COMPLETE, NF_SIGNAL },
+    { winhttp_websocket_close,            WINHTTP_CALLBACK_STATUS_CLOSE_COMPLETE, NF_SIGNAL },
+    { winhttp_close_handle,               WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING },
+    { winhttp_close_handle,               WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION, NF_WINE_ALLOW },
+    { winhttp_close_handle,               WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED, NF_WINE_ALLOW },
+    { winhttp_close_handle,               WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING },
+    { winhttp_close_handle,               WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING },
+    { winhttp_close_handle,               WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING, NF_SIGNAL }
+};
+
+static void test_websocket(void)
+{
+    HANDLE session, connection, request, socket, event;
+    WINHTTP_WEB_SOCKET_BUFFER_TYPE type;
+    DWORD size, status, err;
+    BOOL ret, unload = TRUE;
+    struct info info, *context = &info;
+    char buffer[1024];
+    USHORT close_status;
+
+    if (!pWinHttpWebSocketCompleteUpgrade)
+    {
+        win_skip( "WinHttpWebSocketCompleteUpgrade not supported\n" );
+        return;
+    }
+
+    info.test  = websocket_test;
+    info.count = ARRAY_SIZE( websocket_test );
+    info.index = 0;
+    info.wait  = CreateEventW( NULL, FALSE, FALSE, NULL );
+
+    session = WinHttpOpen( L"winetest", 0, NULL, NULL, WINHTTP_FLAG_ASYNC );
+    ok( session != NULL, "got %u\n", GetLastError() );
+
+    event = CreateEventW( NULL, FALSE, FALSE, NULL );
+    ret = WinHttpSetOption( session, WINHTTP_OPTION_UNLOAD_NOTIFY_EVENT, &event, sizeof(event) );
+    if (!ret)
+    {
+        win_skip( "Unload event not supported\n" );
+        unload = FALSE;
+    }
+
+    SetLastError( 0xdeadbeef );
+    WinHttpSetStatusCallback( session, check_notification, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, 0 );
+    err = GetLastError();
+    ok( err == ERROR_SUCCESS || broken(err == 0xdeadbeef) /* < win7 */, "got %u\n", err );
+
+    SetLastError( 0xdeadbeef );
+    ret = WinHttpSetOption( session, WINHTTP_OPTION_CONTEXT_VALUE, &context, sizeof(context) );
+    err = GetLastError();
+    ok( ret, "got %u\n", err );
+    ok( err == ERROR_SUCCESS || broken(err == 0xdeadbeef) /* < win7 */, "got %u\n", err);
+
+    setup_test( &info, winhttp_connect, __LINE__ );
+    SetLastError( 0xdeadbeef );
+    connection = WinHttpConnect( session, L"echo.websocket.org", 0, 0 );
+    err = GetLastError();
+    ok( connection != NULL, "got %u\n", err);
+    ok( err == ERROR_SUCCESS || broken(err == WSAEINVAL) /* < win7 */, "got %u\n", err );
+
+    setup_test( &info, winhttp_open_request, __LINE__ );
+    SetLastError( 0xdeadbeef );
+    request = WinHttpOpenRequest( connection, NULL, L"/", NULL, NULL, NULL, 0 );
+    err = GetLastError();
+    ok( request != NULL, "got %u\n", err );
+    ok( err == ERROR_SUCCESS, "got %u\n", err );
+
+    ret = WinHttpSetOption( request, WINHTTP_OPTION_UPGRADE_TO_WEB_SOCKET, NULL, 0 );
+    ok( ret, "got %u\n", GetLastError() );
+
+    setup_test( &info, winhttp_send_request, __LINE__ );
+    SetLastError( 0xdeadbeef );
+    ret = WinHttpSendRequest( request, NULL, 0, NULL, 0, 0, 0 );
+    err = GetLastError();
+    if (!ret && (err == ERROR_WINHTTP_CANNOT_CONNECT || err == ERROR_WINHTTP_TIMEOUT))
+    {
+        skip( "connection failed, skipping\n" );
+        WinHttpCloseHandle( request );
+        WinHttpCloseHandle( connection );
+        WinHttpCloseHandle( session );
+        CloseHandle( info.wait );
+        return;
+    }
+    ok( ret, "got %u\n", err );
+    ok( err == ERROR_SUCCESS, "got %u\n", err );
+    WaitForSingleObject( info.wait, INFINITE );
+
+    setup_test( &info, winhttp_receive_response, __LINE__ );
+    SetLastError( 0xdeadbeef );
+    ret = WinHttpReceiveResponse( request, NULL );
+    err = GetLastError();
+    ok( ret, "got %u\n", err );
+    ok( err == ERROR_SUCCESS, "got %u\n", err );
+    WaitForSingleObject( info.wait, INFINITE );
+
+    size = sizeof(status);
+    SetLastError( 0xdeadbeef );
+    ret = WinHttpQueryHeaders( request, WINHTTP_QUERY_STATUS_CODE|WINHTTP_QUERY_FLAG_NUMBER, NULL, &status, &size, NULL );
+    err = GetLastError();
+    ok( ret, "failed unexpectedly %u\n", err );
+    ok( status == 101, "got %u\n", status );
+    ok( err == ERROR_SUCCESS || broken(err == 0xdeadbeef) /* < win7 */, "got %u\n", err );
+
+    setup_test( &info, winhttp_websocket_complete_upgrade, __LINE__ );
+    SetLastError( 0xdeadbeef );
+    socket = pWinHttpWebSocketCompleteUpgrade( request, (DWORD_PTR)context );
+    err = GetLastError();
+    ok( socket != NULL, "got %u\n", err );
+    ok( err == ERROR_SUCCESS, "got %u\n", err );
+    WaitForSingleObject( info.wait, INFINITE );
+
+    setup_test( &info, winhttp_websocket_send, __LINE__ );
+    err = pWinHttpWebSocketSend( socket, 0, (void *)"hello", sizeof("hello") );
+    ok( err == ERROR_SUCCESS, "got %u\n", err );
+    WaitForSingleObject( info.wait, INFINITE );
+
+    setup_test( &info, winhttp_websocket_receive, __LINE__ );
+    buffer[0] = 0;
+    size = 0xdeadbeef;
+    type = 0xdeadbeef;
+    err = pWinHttpWebSocketReceive( socket, buffer, sizeof(buffer), &size, &type );
+    ok( err == ERROR_SUCCESS, "got %u\n", err );
+    WaitForSingleObject( info.wait, INFINITE );
+    ok( size == 0xdeadbeef, "got %u\n", size );
+    ok( type == 0xdeadbeef, "got %u\n", type );
+    ok( buffer[0], "unexpected data\n" );
+
+    setup_test( &info, winhttp_websocket_shutdown, __LINE__ );
+    err = pWinHttpWebSocketShutdown( socket, 1000, (void *)"success", sizeof("success") );
+    ok( err == ERROR_SUCCESS, "got %u\n", err );
+    WaitForSingleObject( info.wait, INFINITE );
+
+    setup_test( &info, winhttp_websocket_close, __LINE__ );
+    ret = pWinHttpWebSocketClose( socket, 1000, (void *)"success", sizeof("success") );
+    ok( err == ERROR_SUCCESS, "got %u\n", err );
+    WaitForSingleObject( info.wait, INFINITE );
+
+    close_status = 0xdead;
+    size = sizeof(buffer) + 1;
+    err = pWinHttpWebSocketQueryCloseStatus( socket, &close_status, buffer, sizeof(buffer), &size );
+    ok( err == ERROR_SUCCESS, "got %u\n", err );
+    ok( close_status == 1000, "got %u\n", close_status );
+    ok( size <= sizeof(buffer), "got %u\n", size );
+
+    setup_test( &info, winhttp_close_handle, __LINE__ );
+    WinHttpCloseHandle( socket );
+    WinHttpCloseHandle( request );
+    WinHttpCloseHandle( connection );
+
+    if (unload)
+    {
+        status = WaitForSingleObject( event, 0 );
+        ok( status == WAIT_TIMEOUT, "got %08x\n", status );
+    }
+    WinHttpCloseHandle( session );
+    WaitForSingleObject( info.wait, INFINITE );
+    end_test( &info, __LINE__ );
+
+    if (unload)
+    {
+        status = WaitForSingleObject( event, 2000 );
+        ok( status == WAIT_OBJECT_0, "got %08x\n", status );
+    }
+    CloseHandle( event );
+    CloseHandle( info.wait );
+    end_test( &info, __LINE__ );
+}
+
 static const char okmsg[] =
 "HTTP/1.1 200 OK\r\n"
 "Server: winetest\r\n"
@@ -1001,13 +1198,22 @@ static void test_persistent_connection(int port)
 
 START_TEST (notification)
 {
+    HMODULE mod = GetModuleHandleA( "winhttp.dll" );
     struct server_info si;
     HANDLE thread;
     DWORD ret;
 
+    pWinHttpWebSocketClose = (void *)GetProcAddress( mod, "WinHttpWebSocketClose" );
+    pWinHttpWebSocketCompleteUpgrade = (void *)GetProcAddress( mod, "WinHttpWebSocketCompleteUpgrade" );
+    pWinHttpWebSocketQueryCloseStatus = (void *)GetProcAddress( mod, "WinHttpWebSocketQueryCloseStatus" );
+    pWinHttpWebSocketReceive = (void *)GetProcAddress( mod, "WinHttpWebSocketReceive" );
+    pWinHttpWebSocketSend = (void *)GetProcAddress( mod, "WinHttpWebSocketSend" );
+    pWinHttpWebSocketShutdown = (void *)GetProcAddress( mod, "WinHttpWebSocketShutdown" );
+
     test_connection_cache();
     test_redirect();
     test_async();
+    test_websocket();
 
     si.event = CreateEventW( NULL, 0, 0, NULL );
     si.port = 7533;
From 6d564bd53e047654fd8e5b0265ad9eb485452e34 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 24 Jun 2020 10:33:09 +0200
Subject: [PATCH] winhttp: Add support for WebSocket fragment buffers.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 73 ++++++++++++++--------------------
 dlls/winhttp/winhttp_private.h | 19 ++++++++-
 2 files changed, 48 insertions(+), 44 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 631fbb004f1..457abb9f84c 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3156,33 +3156,16 @@ static DWORD send_bytes( struct netconn *netconn, char *bytes, int len )
     return (count == len) ? ERROR_SUCCESS : ERROR_INTERNAL_ERROR;
 }
 
-/* rfc6455 */
-enum opcode
-{
-    OPCODE_CONTINUE  = 0x00,
-    OPCODE_TEXT      = 0x01,
-    OPCODE_BINARY    = 0x02,
-    OPCODE_RESERVED3 = 0x03,
-    OPCODE_RESERVED4 = 0x04,
-    OPCODE_RESERVED5 = 0x05,
-    OPCODE_RESERVED6 = 0x06,
-    OPCODE_RESERVED7 = 0x07,
-    OPCODE_CLOSE     = 0x08,
-    OPCODE_PING      = 0x09,
-    OPCODE_PONG      = 0x0a,
-    OPCODE_INVALID   = 0xff,
-};
-
-static enum opcode map_buffer_type( WINHTTP_WEB_SOCKET_BUFFER_TYPE type )
+static enum socket_opcode map_buffer_type( WINHTTP_WEB_SOCKET_BUFFER_TYPE type )
 {
     switch (type)
     {
-    case WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE:   return OPCODE_TEXT;
-    case WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE: return OPCODE_BINARY;
-    case WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE:          return OPCODE_CLOSE;
+    case WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE:   return SOCKET_OPCODE_TEXT;
+    case WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE: return SOCKET_OPCODE_BINARY;
+    case WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE:          return SOCKET_OPCODE_CLOSE;
     default:
         FIXME("buffer type %u not supported\n", type);
-        return OPCODE_INVALID;
+        return SOCKET_OPCODE_INVALID;
     }
 }
 
@@ -3194,10 +3177,10 @@ static DWORD send_frame( struct netconn *netconn, WINHTTP_WEB_SOCKET_BUFFER_TYPE
                          DWORD buflen, BOOL final )
 {
     DWORD i = 0, j, ret, offset = 2, len = buflen;
-    enum opcode opcode = map_buffer_type( type );
+    enum socket_opcode opcode = map_buffer_type( type );
     char hdr[14], byte, *mask;
 
-    if (opcode == OPCODE_CLOSE) len += sizeof(status);
+    if (opcode == SOCKET_OPCODE_CLOSE) len += sizeof(status);
 
     hdr[0] = final ? (char)FIN_BIT : 0;
     hdr[0] |= opcode;
@@ -3224,7 +3207,7 @@ static DWORD send_frame( struct netconn *netconn, WINHTTP_WEB_SOCKET_BUFFER_TYPE
     RtlGenRandom( mask, 4 );
     if ((ret = send_bytes( netconn, hdr, offset + 4 ))) return ret;
 
-    if (opcode == OPCODE_CLOSE) /* prepend status code */
+    if (opcode == SOCKET_OPCODE_CLOSE) /* prepend status code */
     {
         byte = (status >> 8) ^ mask[i++ % 4];
         if ((ret = send_bytes( netconn, &byte, 1 ))) return ret;
@@ -3331,34 +3314,39 @@ static DWORD receive_bytes( struct netconn *netconn, char *buf, DWORD len, DWORD
     return ERROR_SUCCESS;
 }
 
-static WINHTTP_WEB_SOCKET_BUFFER_TYPE map_opcode( enum opcode opcode )
+static WINHTTP_WEB_SOCKET_BUFFER_TYPE map_opcode( enum socket_opcode opcode, BOOL fragment )
 {
     switch (opcode)
     {
-    case OPCODE_TEXT:   return WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE;
-    case OPCODE_BINARY: return WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE;
-    case OPCODE_CLOSE:  return WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE;
+    case SOCKET_OPCODE_TEXT:
+        if (fragment) return WINHTTP_WEB_SOCKET_UTF8_FRAGMENT_BUFFER_TYPE;
+        return WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE;
+
+    case SOCKET_OPCODE_BINARY:
+        if (fragment) return WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE;
+        return WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE;
+
+    case SOCKET_OPCODE_CLOSE:
+        return WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE;
+
     default:
-        ERR("opcode %u not handled\n", opcode);
+        FIXME("opcode %u not handled\n", opcode);
         return ~0u;
     }
 }
 
-static DWORD receive_frame( struct netconn *netconn, DWORD *ret_len, WINHTTP_WEB_SOCKET_BUFFER_TYPE *ret_type )
+static DWORD receive_frame( struct netconn *netconn, DWORD *ret_len, enum socket_opcode *opcode )
 {
-    WINHTTP_WEB_SOCKET_BUFFER_TYPE type;
     DWORD ret, len, count;
-    enum opcode opcode;
     char hdr[2];
 
     if ((ret = receive_bytes( netconn, hdr, sizeof(hdr), &count ))) return ret;
-    if (count != sizeof(hdr) || (hdr[0] & RESERVED_BIT) || (hdr[1] & MASK_BIT))
+    if (count != sizeof(hdr) || (hdr[0] & RESERVED_BIT) || (hdr[1] & MASK_BIT) ||
+        (map_opcode( hdr[0] & 0xf, FALSE ) == ~0u))
     {
         return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
     }
-
-    opcode = hdr[0] & 0xf;
-    type = map_opcode( opcode );
+    *opcode = hdr[0] & 0xf;
 
     len = hdr[1] & ~MASK_BIT;
     if (len == 126)
@@ -3378,7 +3366,6 @@ static DWORD receive_frame( struct netconn *netconn, DWORD *ret_len, WINHTTP_WEB
     }
 
     *ret_len = len;
-    *ret_type = type;
     return ERROR_SUCCESS;
 }
 
@@ -3387,7 +3374,7 @@ static DWORD socket_receive( struct socket *socket, void *buf, DWORD len, DWORD
 {
     DWORD count, ret = ERROR_SUCCESS;
 
-    if (!socket->read_size) ret = receive_frame( socket->request->netconn, &socket->read_size, &socket->buf_type );
+    if (!socket->read_size) ret = receive_frame( socket->request->netconn, &socket->read_size, &socket->opcode );
     if (!ret) ret = receive_bytes( socket->request->netconn, buf, min(len, socket->read_size), &count );
     if (!ret)
     {
@@ -3395,7 +3382,7 @@ static DWORD socket_receive( struct socket *socket, void *buf, DWORD len, DWORD
         if (!async)
         {
             *ret_len = count;
-            *ret_type = socket->buf_type;
+            *ret_type = map_opcode( socket->opcode, socket->read_size != 0 );
         }
     }
 
@@ -3405,7 +3392,7 @@ static DWORD socket_receive( struct socket *socket, void *buf, DWORD len, DWORD
         {
             WINHTTP_WEB_SOCKET_STATUS status;
             status.dwBytesTransferred = count;
-            status.eBufferType        = socket->buf_type;
+            status.eBufferType        = map_opcode( socket->opcode, socket->read_size != 0 );
             send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_READ_COMPLETE, &status, sizeof(status) );
         }
         else
@@ -3558,8 +3545,8 @@ static DWORD socket_close( struct socket *socket, USHORT status, const void *rea
         socket->state = SOCKET_STATE_SHUTDOWN;
     }
 
-    if ((ret = receive_frame( netconn, &count, &socket->buf_type ))) goto done;
-    if (socket->buf_type != WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE || (count && count > sizeof(socket->reason)))
+    if ((ret = receive_frame( netconn, &count, &socket->opcode ))) goto done;
+    if (socket->opcode != SOCKET_OPCODE_CLOSE || (count && count > sizeof(socket->reason)))
     {
         ret = ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
         goto done;
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 41ada14c0ce..4a943750061 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -221,6 +221,23 @@ enum socket_state
     SOCKET_STATE_CLOSED   = 2,
 };
 
+/* rfc6455 */
+enum socket_opcode
+{
+    SOCKET_OPCODE_CONTINUE  = 0x00,
+    SOCKET_OPCODE_TEXT      = 0x01,
+    SOCKET_OPCODE_BINARY    = 0x02,
+    SOCKET_OPCODE_RESERVED3 = 0x03,
+    SOCKET_OPCODE_RESERVED4 = 0x04,
+    SOCKET_OPCODE_RESERVED5 = 0x05,
+    SOCKET_OPCODE_RESERVED6 = 0x06,
+    SOCKET_OPCODE_RESERVED7 = 0x07,
+    SOCKET_OPCODE_CLOSE     = 0x08,
+    SOCKET_OPCODE_PING      = 0x09,
+    SOCKET_OPCODE_PONG      = 0x0a,
+    SOCKET_OPCODE_INVALID   = 0xff,
+};
+
 struct socket
 {
     struct object_header hdr;
@@ -228,7 +245,7 @@ struct socket
     enum socket_state state;
     struct queue send_q;
     struct queue recv_q;
-    WINHTTP_WEB_SOCKET_BUFFER_TYPE buf_type;
+    enum socket_opcode opcode;
     DWORD read_size;
     USHORT status;
     char reason[128];
From e3ab70b82ac590e117dca4158041357541a8b23a Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Wed, 24 Jun 2020 10:33:10 +0200
Subject: [PATCH] winhttp/tests: Add more WebSocket tests.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/tests/winhttp.c | 156 +++++++++++++++++++++++++++++++++--
 1 file changed, 148 insertions(+), 8 deletions(-)

diff --git a/dlls/winhttp/tests/winhttp.c b/dlls/winhttp/tests/winhttp.c
index be02bbe2502..12f5136973f 100644
--- a/dlls/winhttp/tests/winhttp.c
+++ b/dlls/winhttp/tests/winhttp.c
@@ -27,7 +27,6 @@
 #include <winhttp.h>
 #include <wincrypt.h>
 #include <winreg.h>
-#include <stdio.h>
 #include <initguid.h>
 #include <httprequest.h>
 #include <httprequestid.h>
@@ -37,7 +36,12 @@
 
 DEFINE_GUID(GUID_NULL,0,0,0,0,0,0,0,0,0,0,0);
 
+static DWORD (WINAPI *pWinHttpWebSocketClose)(HINTERNET,USHORT,void*,DWORD);
 static HINTERNET (WINAPI *pWinHttpWebSocketCompleteUpgrade)(HINTERNET,DWORD_PTR);
+static DWORD (WINAPI *pWinHttpWebSocketQueryCloseStatus)(HINTERNET,USHORT*,void*,DWORD,DWORD*);
+static DWORD (WINAPI *pWinHttpWebSocketReceive)(HINTERNET,void*,DWORD,DWORD*,WINHTTP_WEB_SOCKET_BUFFER_TYPE*);
+static DWORD (WINAPI *pWinHttpWebSocketSend)(HINTERNET,WINHTTP_WEB_SOCKET_BUFFER_TYPE,void*,DWORD);
+static DWORD (WINAPI *pWinHttpWebSocketShutdown)(HINTERNET,USHORT,void*,DWORD);
 
 static BOOL proxy_active(void)
 {
@@ -2440,9 +2444,9 @@ static DWORD CALLBACK server_thread(LPVOID param)
                 strcat(headers, "\r\n\r\n");
 
                 send(c, headers, strlen(headers), 0);
+                continue;
             }
             else send(c, notokmsg, sizeof(notokmsg) - 1, 0);
-            continue;
         }
         if (strstr(buffer, "GET /quit"))
         {
@@ -3097,11 +3101,13 @@ static void test_head_request(int port)
 
 static void test_websocket(int port)
 {
-    HINTERNET session, connection, request, socket;
+    HINTERNET session, connection, request, socket, socket2;
     DWORD size, len, count, status, index, error;
     DWORD_PTR ctx;
+    WINHTTP_WEB_SOCKET_BUFFER_TYPE type;
     WCHAR header[32];
-    char buf[128];
+    char buf[128], *large_buf;
+    USHORT close_status;
     BOOL ret;
 
     if (!pWinHttpWebSocketCompleteUpgrade)
@@ -3215,7 +3221,7 @@ static void test_websocket(int port)
     len = 0xdeadbeef;
     size = sizeof(len);
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CONTENT_LENGTH | WINHTTP_QUERY_FLAG_NUMBER, NULL, &len,
-                              &size, 0);
+                              &size, NULL);
     ok(!ret, "success\n");
 
     index = 0;
@@ -3226,6 +3232,12 @@ static void test_websocket(int port)
     socket = pWinHttpWebSocketCompleteUpgrade(request, 0);
     ok(socket != NULL, "got %u\n", GetLastError());
 
+    size = sizeof(header);
+    ret = WinHttpQueryHeaders(socket, WINHTTP_QUERY_UPGRADE, NULL, &header, &size, NULL);
+    error = GetLastError();
+    ok(!ret, "success\n");
+    ok(error == ERROR_WINHTTP_INCORRECT_HANDLE_TYPE, "got %u\n", error);
+
     header[0] = 0;
     size = sizeof(header);
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_UPGRADE, NULL, &header, &size, NULL);
@@ -3243,16 +3255,24 @@ static void test_websocket(int port)
     ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_CUSTOM, L"Sec-WebSocket-Accept", buf, &size, &index);
     ok(ret, "got %u\n", GetLastError());
 
-    /* Send/Receive on websock */
-
-    ret = WinHttpCloseHandle(connection);
+    /* sending request again generates new key */
+    ret = WinHttpSendRequest(request, NULL, 0, NULL, 0, 0, 0);
     ok(ret, "got %u\n", GetLastError());
 
+    /* and creates a new websocket */
+    socket2 = pWinHttpWebSocketCompleteUpgrade(request, 0);
+    ok(socket2 != NULL, "got %u\n", GetLastError());
+    ok(socket2 != socket, "got same socket\n");
+
+    WinHttpCloseHandle(connection);
     /* request handle is still valid */
     size = sizeof(ctx);
     ret = WinHttpQueryOption(request, WINHTTP_OPTION_CONTEXT_VALUE, &ctx, &size);
     ok(ret, "got %u\n", GetLastError());
 
+    ret = WinHttpCloseHandle(socket2);
+    ok(ret, "got %u\n", GetLastError());
+
     ret = WinHttpCloseHandle(socket);
     ok(ret, "got %u\n", GetLastError());
 
@@ -3267,6 +3287,121 @@ static void test_websocket(int port)
 
     ret = WinHttpCloseHandle(request);
     ok(ret, "got %u\n", GetLastError());
+
+    session = WinHttpOpen(L"winetest", 0, NULL, NULL, 0);
+    ok(session != NULL, "got %u\n", GetLastError());
+
+    connection = WinHttpConnect(session, L"echo.websocket.org", 0, 0);
+    ok(connection != NULL, "got %u\n", GetLastError());
+
+    request = WinHttpOpenRequest(connection, L"GET", L"/", NULL, NULL, NULL, 0);
+    ok(request != NULL, "got %u\n", GetLastError());
+
+    ret = WinHttpSetOption(request, WINHTTP_OPTION_UPGRADE_TO_WEB_SOCKET, NULL, 0);
+    ok(ret, "got %u\n", GetLastError());
+
+    ret = WinHttpSendRequest(request, NULL, 0, NULL, 0, 0, 0);
+    ok(ret, "got %u\n", GetLastError());
+
+    ret = WinHttpReceiveResponse(request, NULL);
+    ok(ret, "got %u\n", GetLastError());
+
+    status = 0xdeadbeef;
+    size = sizeof(status);
+    ret = WinHttpQueryHeaders(request, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, NULL, &status,
+                              &size, NULL);
+    ok(ret, "got %u\n", GetLastError());
+    ok(status == HTTP_STATUS_SWITCH_PROTOCOLS, "got %u\n", status);
+
+    socket = pWinHttpWebSocketCompleteUpgrade(request, 0);
+    ok(socket != NULL, "got %u\n", GetLastError());
+
+    error = pWinHttpWebSocketSend(socket, WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE, NULL, 1);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    large_buf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(buf) * 2);
+    memcpy(large_buf, "hello", sizeof("hello"));
+    memcpy(large_buf + sizeof(buf), "world", sizeof("world"));
+    error = pWinHttpWebSocketSend(socket, WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE, large_buf, sizeof(buf) * 2);
+    ok(!error, "got %u\n", error);
+    HeapFree(GetProcessHeap(), 0, large_buf);
+
+    error = pWinHttpWebSocketReceive(socket, NULL, 0, NULL, NULL);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    error = pWinHttpWebSocketReceive(socket, buf, 0, NULL, NULL);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    error = pWinHttpWebSocketReceive(socket, NULL, 1, NULL, NULL);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    buf[0] = 0;
+    count = 0;
+    type = 0xdeadbeef;
+    error = pWinHttpWebSocketReceive(socket, buf, sizeof(buf), &count, &type);
+    ok(!error, "got %u\n", error);
+    ok(buf[0] == 'h', "got %c\n", buf[0]);
+    ok(count == sizeof(buf), "got %u\n", count);
+    ok(type == WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE, "got %u\n", type);
+
+    buf[0] = 0;
+    count = 0;
+    type = 0xdeadbeef;
+    error = pWinHttpWebSocketReceive(socket, buf, sizeof(buf), &count, &type);
+    ok(!error, "got %u\n", error);
+    ok(buf[0] == 'w', "got %c\n", buf[0]);
+    ok(count == sizeof(buf), "got %u\n", count);
+    ok(type == WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE, "got %u\n", type);
+
+    error = pWinHttpWebSocketShutdown(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, NULL, 1);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    error = pWinHttpWebSocketShutdown(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, (void *)"success",
+                                      sizeof("success"));
+    ok(!error, "got %u\n", error);
+
+    error = pWinHttpWebSocketClose(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, NULL, 1);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    error = pWinHttpWebSocketClose(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, (void *)"success2",
+                                   sizeof("success2"));
+    ok(!error, "got %u\n", error);
+
+    error = pWinHttpWebSocketQueryCloseStatus(socket, NULL, NULL, 0, NULL);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    error = pWinHttpWebSocketQueryCloseStatus(socket, &close_status, NULL, 0, NULL);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    error = pWinHttpWebSocketQueryCloseStatus(socket, &close_status, buf, 0, NULL);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    error = pWinHttpWebSocketQueryCloseStatus(socket, &close_status, buf, sizeof(buf), NULL);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    error = pWinHttpWebSocketQueryCloseStatus(socket, NULL, NULL, 0, &len);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    len = 0;
+    error = pWinHttpWebSocketQueryCloseStatus(socket, &close_status, NULL, 0, &len);
+    ok(error == ERROR_INSUFFICIENT_BUFFER, "got %u\n", error);
+    ok(len, "len not set\n");
+
+    error = pWinHttpWebSocketQueryCloseStatus(socket, &close_status, NULL, 1, &len);
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
+    close_status = 0xdead;
+    len = 0xdeadbeef;
+    memset(buf, 0, sizeof(buf));
+    error = pWinHttpWebSocketQueryCloseStatus(socket, &close_status, buf, sizeof(buf), &len);
+    ok(!error, "got %u\n", error);
+    ok(close_status == 1000, "got %08x\n", close_status);
+    ok(len == sizeof("success"), "got %u\n", len);
+
+    WinHttpCloseHandle(socket);
+    WinHttpCloseHandle(request);
+    WinHttpCloseHandle(connection);
+    WinHttpCloseHandle(session);
 }
 
 static void test_not_modified(int port)
@@ -4942,7 +5077,12 @@ START_TEST (winhttp)
     DWORD ret;
     HMODULE mod = GetModuleHandleA("winhttp.dll");
 
+    pWinHttpWebSocketClose = (void *)GetProcAddress(mod, "WinHttpWebSocketClose");
     pWinHttpWebSocketCompleteUpgrade = (void *)GetProcAddress(mod, "WinHttpWebSocketCompleteUpgrade");
+    pWinHttpWebSocketQueryCloseStatus = (void *)GetProcAddress(mod, "WinHttpWebSocketQueryCloseStatus");
+    pWinHttpWebSocketSend = (void *)GetProcAddress(mod, "WinHttpWebSocketSend");
+    pWinHttpWebSocketShutdown = (void *)GetProcAddress(mod, "WinHttpWebSocketShutdown");
+    pWinHttpWebSocketReceive = (void *)GetProcAddress(mod, "WinHttpWebSocketReceive");
 
     test_WinHttpOpenRequest();
     test_WinHttpSendRequest();
From b9038c736b829a3cd5b615d6c41df8b71f938f54 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Thu, 25 Jun 2020 11:00:23 +0200
Subject: [PATCH] winhttp: Set socket state before sending notifications.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c | 21 ++++++++++++---------
 1 file changed, 12 insertions(+), 9 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 457abb9f84c..623fdf5db59 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3372,10 +3372,11 @@ static DWORD receive_frame( struct netconn *netconn, DWORD *ret_len, enum socket
 static DWORD socket_receive( struct socket *socket, void *buf, DWORD len, DWORD *ret_len,
                              WINHTTP_WEB_SOCKET_BUFFER_TYPE *ret_type, BOOL async )
 {
+    struct netconn *netconn = socket->request->netconn;
     DWORD count, ret = ERROR_SUCCESS;
 
-    if (!socket->read_size) ret = receive_frame( socket->request->netconn, &socket->read_size, &socket->opcode );
-    if (!ret) ret = receive_bytes( socket->request->netconn, buf, min(len, socket->read_size), &count );
+    if (!socket->read_size) ret = receive_frame( netconn, &socket->read_size, &socket->opcode );
+    if (!ret) ret = receive_bytes( netconn, buf, min(len, socket->read_size), &count );
     if (!ret)
     {
         socket->read_size -= count;
@@ -3385,7 +3386,6 @@ static DWORD socket_receive( struct socket *socket, void *buf, DWORD len, DWORD
             *ret_type = map_opcode( socket->opcode, socket->read_size != 0 );
         }
     }
-
     if (async)
     {
         if (!ret)
@@ -3458,9 +3458,13 @@ DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, D
 
 static DWORD socket_shutdown( struct socket *socket, USHORT status, const void *reason, DWORD len, BOOL async )
 {
+    struct netconn *netconn = socket->request->netconn;
     DWORD ret;
 
-    ret = send_frame( socket->request->netconn, WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE, status, reason, len, TRUE );
+    if (!(ret = send_frame( netconn, WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE, status, reason, len, TRUE )))
+    {
+        socket->state = SOCKET_STATE_SHUTDOWN;
+    }
     if (async)
     {
         if (!ret) send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_SHUTDOWN_COMPLETE, NULL, 0 );
@@ -3473,8 +3477,6 @@ static DWORD socket_shutdown( struct socket *socket, USHORT status, const void *
             send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_REQUEST_ERROR, &result, sizeof(result) );
         }
     }
-
-    if (!ret) socket->state = SOCKET_STATE_SHUTDOWN;
     return ret;
 }
 
@@ -3559,7 +3561,10 @@ static DWORD socket_close( struct socket *socket, USHORT status, const void *rea
         goto done;
     }
     socket->status = RtlUshortByteSwap( socket->status );
-    ret = receive_bytes( netconn, socket->reason, sizeof(socket->reason), &socket->reason_len );
+    if (!(ret = receive_bytes( netconn, socket->reason, sizeof(socket->reason), &socket->reason_len )))
+    {
+        socket->state = SOCKET_STATE_CLOSED;
+    }
 
 done:
     if (async)
@@ -3574,8 +3579,6 @@ static DWORD socket_close( struct socket *socket, USHORT status, const void *rea
             send_callback( &socket->hdr, WINHTTP_CALLBACK_STATUS_REQUEST_ERROR, &result, sizeof(result) );
         }
     }
-
-    if (!ret) socket->state = SOCKET_STATE_CLOSED;
     return ret;
 }
 
From 968b3745bb02fde13bfafce102de973fec7c6bd2 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Thu, 25 Jun 2020 11:00:24 +0200
Subject: [PATCH] winhttp: Status and reason are optional in the close
 response.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c | 25 ++++++++++---------------
 1 file changed, 10 insertions(+), 15 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 623fdf5db59..c15be385925 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3310,7 +3310,7 @@ static DWORD receive_bytes( struct netconn *netconn, char *buf, DWORD len, DWORD
 {
     DWORD err;
     if ((err = netconn_recv( netconn, buf, len, 0, (int *)ret_len ))) return err;
-    if (len && !*ret_len) return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
+    if (*ret_len != len) return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
     return ERROR_SUCCESS;
 }
 
@@ -3341,8 +3341,7 @@ static DWORD receive_frame( struct netconn *netconn, DWORD *ret_len, enum socket
     char hdr[2];
 
     if ((ret = receive_bytes( netconn, hdr, sizeof(hdr), &count ))) return ret;
-    if (count != sizeof(hdr) || (hdr[0] & RESERVED_BIT) || (hdr[1] & MASK_BIT) ||
-        (map_opcode( hdr[0] & 0xf, FALSE ) == ~0u))
+    if ((hdr[0] & RESERVED_BIT) || (hdr[1] & MASK_BIT) || (map_opcode( hdr[0] & 0xf, FALSE ) == ~0u))
     {
         return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
     }
@@ -3353,14 +3352,12 @@ static DWORD receive_frame( struct netconn *netconn, DWORD *ret_len, enum socket
     {
         USHORT len16;
         if ((ret = receive_bytes( netconn, (char *)&len16, sizeof(len16), &count ))) return ret;
-        if (count != sizeof(len16)) return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
         len = RtlUshortByteSwap( len16 );
     }
     else if (len == 127)
     {
         ULONGLONG len64;
         if ((ret = receive_bytes( netconn, (char *)&len64, sizeof(len64), &count ))) return ret;
-        if (count != sizeof(len64)) return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
         if ((len64 = RtlUlonglongByteSwap( len64 )) > ~0u) return ERROR_NOT_SUPPORTED;
         len = len64;
     }
@@ -3548,23 +3545,21 @@ static DWORD socket_close( struct socket *socket, USHORT status, const void *rea
     }
 
     if ((ret = receive_frame( netconn, &count, &socket->opcode ))) goto done;
-    if (socket->opcode != SOCKET_OPCODE_CLOSE || (count && count > sizeof(socket->reason)))
+    if (socket->opcode != SOCKET_OPCODE_CLOSE ||
+        (count && (count < sizeof(socket->status) || count > sizeof(socket->status) + sizeof(socket->reason))))
     {
         ret = ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
         goto done;
     }
 
-    if ((ret = receive_bytes( netconn, (char *)&socket->status, sizeof(socket->status), &count ))) goto done;
-    if (count != sizeof(socket->status))
+    if (count)
     {
-        ret = ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
-        goto done;
-    }
-    socket->status = RtlUshortByteSwap( socket->status );
-    if (!(ret = receive_bytes( netconn, socket->reason, sizeof(socket->reason), &socket->reason_len )))
-    {
-        socket->state = SOCKET_STATE_CLOSED;
+        DWORD reason_len = count - sizeof(socket->status);
+        if ((ret = receive_bytes( netconn, (char *)&socket->status, sizeof(socket->status), &count ))) goto done;
+        socket->status = RtlUshortByteSwap( socket->status );
+        if ((ret = receive_bytes( netconn, socket->reason, reason_len, &socket->reason_len ))) goto done;
     }
+    socket->state = SOCKET_STATE_CLOSED;
 
 done:
     if (async)
From 23db5357bb0b473ecaba6cb4466e474f07cf4645 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Thu, 25 Jun 2020 11:00:25 +0200
Subject: [PATCH] winhttp: Add stubs for new proxy functions.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/session.c    | 107 ++++++++++++++++++++++++++++++++++++++
 dlls/winhttp/winhttp.spec |  12 +++++
 2 files changed, 119 insertions(+)

diff --git a/dlls/winhttp/session.c b/dlls/winhttp/session.c
index 186b70e4a2d..228eb646ae0 100644
--- a/dlls/winhttp/session.c
+++ b/dlls/winhttp/session.c
@@ -2028,6 +2028,113 @@ BOOL WINAPI WinHttpSetDefaultProxyConfiguration( WINHTTP_PROXY_INFO *info )
     return ret;
 }
 
+/***********************************************************************
+ *          WinHttpCreateProxyResolver (winhttp.@)
+ */
+DWORD WINAPI WinHttpCreateProxyResolver( HINTERNET hsession, HINTERNET *hresolver )
+{
+    FIXME("%p, %p\n", hsession, hresolver);
+    return ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
+}
+
+/***********************************************************************
+ *          WinHttpFreeProxyResult (winhttp.@)
+ */
+void WINAPI WinHttpFreeProxyResult( WINHTTP_PROXY_RESULT *result )
+{
+    FIXME("%p\n", result);
+}
+
+/***********************************************************************
+ *          WinHttpFreeProxyResultEx (winhttp.@)
+ */
+void WINAPI WinHttpFreeProxyResultEx( WINHTTP_PROXY_RESULT_EX *result )
+{
+    FIXME("%p\n", result);
+}
+
+/***********************************************************************
+ *          WinHttpFreeProxySettings (winhttp.@)
+ */
+void WINAPI WinHttpFreeProxySettings( WINHTTP_PROXY_SETTINGS *settings )
+{
+    FIXME("%p\n", settings);
+}
+
+/***********************************************************************
+ *          WinHttpGetProxyForUrlEx (winhttp.@)
+ */
+DWORD WINAPI WinHttpGetProxyForUrlEx( HINTERNET hresolver, const WCHAR *url, WINHTTP_AUTOPROXY_OPTIONS *options,
+                                      DWORD_PTR ctx )
+{
+    FIXME("%p, %s, %p, %lx\n", hresolver, debugstr_w(url), options, ctx);
+    return ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
+}
+
+/***********************************************************************
+ *          WinHttpGetProxyForUrlEx2 (winhttp.@)
+ */
+DWORD WINAPI WinHttpGetProxyForUrlEx2( HINTERNET hresolver, const WCHAR *url, WINHTTP_AUTOPROXY_OPTIONS *options,
+                                       DWORD selection_len, BYTE *selection, DWORD_PTR ctx )
+{
+    FIXME("%p, %s, %p, %u, %p, %lx\n", hresolver, debugstr_w(url), options, selection_len, selection, ctx);
+    return ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
+}
+
+/***********************************************************************
+ *          WinHttpGetProxyResult (winhttp.@)
+ */
+DWORD WINAPI WinHttpGetProxyResult( HINTERNET hresolver, WINHTTP_PROXY_RESULT *result )
+{
+    FIXME("%p, %p\n", hresolver, result);
+    return ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
+}
+
+/***********************************************************************
+ *          WinHttpGetProxyResultEx (winhttp.@)
+ */
+DWORD WINAPI WinHttpGetProxyResultEx( HINTERNET hresolver, WINHTTP_PROXY_RESULT_EX *result )
+{
+    FIXME("%p, %p\n", hresolver, result);
+    return ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
+}
+
+/***********************************************************************
+ *          WinHttpGetProxySettingsVersion (winhttp.@)
+ */
+DWORD WINAPI WinHttpGetProxySettingsVersion( HINTERNET hsession, DWORD *version )
+{
+    FIXME("%p, %p\n", hsession, version);
+    return ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
+}
+
+/***********************************************************************
+ *          WinHttpReadProxySettings (winhttp.@)
+ */
+DWORD WINAPI WinHttpReadProxySettings( HINTERNET hsession, const WCHAR *connection, BOOL use_defaults,
+                                       BOOL set_autodiscover, DWORD *version, BOOL *defaults_returned,
+                                       WINHTTP_PROXY_SETTINGS *settings)
+{
+    FIXME("%p, %s, %d, %d, %p, %p, %p\n", hsession, debugstr_w(connection), use_defaults, set_autodiscover,
+          version, defaults_returned, settings);
+    return ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
+}
+
+/***********************************************************************
+ *          WinHttpResetAutoProxy (winhttp.@)
+ */
+DWORD WINAPI WinHttpResetAutoProxy( HINTERNET hsession, DWORD flags )
+{
+    FIXME("%p, %08x\n", hsession, flags);
+    return ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
+}
+
+DWORD WINAPI WinHttpWriteProxySettings( HINTERNET hsession, BOOL force, WINHTTP_PROXY_SETTINGS *settings )
+{
+    FIXME("%p, %d, %p\n", hsession, force, settings);
+    return ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
+}
+
 /***********************************************************************
  *          WinHttpSetStatusCallback (winhttp.@)
  */
diff --git a/dlls/winhttp/winhttp.spec b/dlls/winhttp/winhttp.spec
index beace245a8c..581918791e3 100644
--- a/dlls/winhttp/winhttp.spec
+++ b/dlls/winhttp/winhttp.spec
@@ -7,11 +7,20 @@
 @ stdcall WinHttpCloseHandle(ptr)
 @ stdcall WinHttpConnect(ptr wstr long long)
 @ stdcall WinHttpCrackUrl(wstr long long ptr)
+@ stdcall WinHttpCreateProxyResolver(ptr ptr)
 @ stdcall WinHttpCreateUrl(ptr long ptr ptr)
 @ stdcall WinHttpDetectAutoProxyConfigUrl(long ptr)
+@ stdcall WinHttpFreeProxyResult(ptr)
+@ stdcall WinHttpFreeProxyResultEx(ptr)
+@ stdcall WinHttpFreeProxySettings(ptr)
 @ stdcall WinHttpGetDefaultProxyConfiguration(ptr)
 @ stdcall WinHttpGetIEProxyConfigForCurrentUser(ptr)
 @ stdcall WinHttpGetProxyForUrl(ptr wstr ptr ptr)
+@ stdcall WinHttpGetProxyForUrlEx(ptr wstr ptr ptr)
+@ stdcall WinHttpGetProxyForUrlEx2(ptr wstr ptr long ptr ptr)
+@ stdcall WinHttpGetProxyResult(ptr ptr)
+@ stdcall WinHttpGetProxyResultEx(ptr ptr)
+@ stdcall WinHttpGetProxySettingsVersion(ptr ptr)
 @ stdcall WinHttpOpen(wstr long wstr wstr long)
 @ stdcall WinHttpOpenRequest(ptr wstr wstr wstr wstr ptr long)
 @ stdcall WinHttpQueryAuthSchemes(ptr ptr ptr ptr)
@@ -19,7 +28,9 @@
 @ stdcall WinHttpQueryHeaders(ptr long wstr ptr ptr ptr)
 @ stdcall WinHttpQueryOption(ptr long ptr ptr)
 @ stdcall WinHttpReadData(ptr ptr long ptr)
+@ stdcall WinHttpReadProxySettings(ptr wstr long long ptr ptr ptr)
 @ stdcall WinHttpReceiveResponse(ptr ptr)
+@ stdcall WinHttpResetAutoProxy(ptr long)
 @ stdcall WinHttpSendRequest(ptr wstr long ptr long long long)
 @ stdcall WinHttpSetCredentials(ptr long long wstr ptr ptr)
 @ stdcall WinHttpSetDefaultProxyConfiguration(ptr)
@@ -35,3 +46,4 @@
 @ stdcall WinHttpWebSocketSend(ptr long ptr long)
 @ stdcall WinHttpWebSocketShutdown(ptr long ptr long)
 @ stdcall WinHttpWriteData(ptr ptr long ptr)
+@ stdcall WinHttpWriteProxySettings(ptr long ptr)

From c7d140d34aa6f40a92f95fd8698501d3283c9296 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 29 Jun 2020 15:46:10 +0200
Subject: [PATCH] winhttp: Reimplement the task queue using thread pool work
 objects.

Simplifies cleanup.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 336 ++++++++++++++++-----------------
 dlls/winhttp/session.c         |  12 +-
 dlls/winhttp/winhttp_private.h |  31 +--
 3 files changed, 169 insertions(+), 210 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index c15be385925..bc3d365f7cd 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -122,92 +122,34 @@ static const WCHAR *attribute_table[] =
     NULL                            /* WINHTTP_QUERY_PASSPORT_CONFIG            = 78 */
 };
 
-static struct task_header *dequeue_task( struct queue *queue )
+static DWORD start_queue( struct queue *queue )
 {
-    struct task_header *task;
+    if (queue->pool) return ERROR_SUCCESS;
 
-    EnterCriticalSection( &queue->cs );
-    TRACE("%u tasks queued in %p\n", list_count(&queue->tasks), queue);
-    task = LIST_ENTRY( list_head( &queue->tasks ), struct task_header, entry );
-    if (task) list_remove( &task->entry );
-    LeaveCriticalSection( &queue->cs );
+    if (!(queue->pool = CreateThreadpool( NULL ))) return GetLastError();
+    SetThreadpoolThreadMinimum( queue->pool, 1 );
+    SetThreadpoolThreadMaximum( queue->pool, 1 );
 
-    TRACE("returning task %p\n", task);
-    return task;
-}
-
-static void CALLBACK run_queue( TP_CALLBACK_INSTANCE *instance, void *ctx )
-{
-    struct queue *queue = ctx;
-    HANDLE handles[] = { queue->wait, queue->cancel };
-
-    for (;;)
-    {
-        DWORD err = WaitForMultipleObjects( 2, handles, FALSE, INFINITE );
-        switch (err)
-        {
-        case WAIT_OBJECT_0:
-        {
-            struct task_header *task;
-            while ((task = dequeue_task( queue )))
-            {
-                task->proc( task );
-                release_object( task->object );
-                heap_free( task );
-            }
-            break;
-        }
-        case WAIT_OBJECT_0 + 1:
-            TRACE("exiting\n");
-            CloseHandle( queue->wait );
-            CloseHandle( queue->cancel );
-            queue->object->vtbl->destroy( queue->object );
-            return;
-
-        default:
-            ERR("wait failed %u (%u)\n", err, GetLastError());
-            break;
-        }
-    }
-}
+    memset( &queue->env, 0, sizeof(queue->env) );
+    queue->env.Version = 1;
+    queue->env.Pool = queue->pool;
 
-static DWORD start_queue( struct object_header *object, struct queue *queue )
-{
-    DWORD ret = ERROR_OUTOFMEMORY;
-
-    if (queue->wait) return ERROR_SUCCESS;
-
-    queue->object = object;
-    list_init( &queue->tasks );
-    if (!(queue->wait = CreateEventW( NULL, FALSE, FALSE, NULL ))) goto error;
-    if (!(queue->cancel = CreateEventW( NULL, FALSE, FALSE, NULL ))) goto error;
-    if (!TrySubmitThreadpoolCallback( run_queue, queue, NULL )) ret = GetLastError();
-    else
-    {
-        queue->proc_running = TRUE;
-        TRACE("started %p\n", queue);
-        return ERROR_SUCCESS;
-    }
-
-error:
-    CloseHandle( queue->wait );
-    queue->wait = NULL;
-    CloseHandle( queue->cancel );
-    queue->cancel = NULL;
-    return ret;
+    TRACE("started %p\n", queue);
+    return ERROR_SUCCESS;
 }
 
-static DWORD queue_task( struct object_header *object, struct queue *queue, struct task_header *task )
+static DWORD queue_task( struct queue *queue, PTP_WORK_CALLBACK task, void *ctx )
 {
+    TP_WORK *work;
     DWORD ret;
-    if ((ret = start_queue( object, queue ))) return ret;
 
-    EnterCriticalSection( &queue->cs );
-    TRACE("queueing task %p in %p\n", task, queue);
-    list_add_tail( &queue->tasks, &task->entry );
-    LeaveCriticalSection( &queue->cs );
+    if ((ret = start_queue( queue ))) return ret;
+
+    if (!(work = CreateThreadpoolWork( task, ctx, &queue->env ))) return GetLastError();
+    TRACE("queueing %p in %p\n", work, queue);
+    SubmitThreadpoolWork( work );
+    CloseThreadpoolWork( work );
 
-    SetEvent( queue->wait );
     return ERROR_SUCCESS;
 }
 
@@ -2216,13 +2158,16 @@ static DWORD send_request( struct request *request, const WCHAR *headers, DWORD
     return ret;
 }
 
-static void task_send_request( struct task_header *task )
+static void CALLBACK task_send_request( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct request *request = (struct request *)task->object;
-    struct send_request *s = (struct send_request *)task;
+    struct send_request *s = ctx;
+
+    TRACE("running %p\n", work);
+    send_request( s->request, s->headers, s->headers_len, s->optional, s->optional_len, s->total_len, s->context, TRUE );
 
-    send_request( request, s->headers, s->headers_len, s->optional, s->optional_len, s->total_len, s->context, TRUE );
+    release_object( &s->request->hdr );
     heap_free( s->headers );
+    heap_free( s );
 }
 
 /***********************************************************************
@@ -2256,8 +2201,7 @@ BOOL WINAPI WinHttpSendRequest( HINTERNET hrequest, LPCWSTR headers, DWORD heade
         struct send_request *s;
 
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
-        s->hdr.object   = &request->hdr;
-        s->hdr.proc     = task_send_request;
+        s->request      = request;
         s->headers      = strdupW( headers );
         s->headers_len  = headers_len;
         s->optional     = optional;
@@ -2266,7 +2210,12 @@ BOOL WINAPI WinHttpSendRequest( HINTERNET hrequest, LPCWSTR headers, DWORD heade
         s->context      = context;
 
         addref_object( &request->hdr );
-        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)s );
+        if ((ret = queue_task( &request->queue, task_send_request, s )))
+        {
+            release_object( &request->hdr );
+            heap_free( s->headers );
+            heap_free( s );
+        }
     }
     else ret = send_request( request, headers, headers_len, optional, optional_len, total_len, context, FALSE );
 
@@ -2797,10 +2746,15 @@ static DWORD receive_response( struct request *request, BOOL async )
     return ret;
 }
 
-static void task_receive_response( struct task_header *task )
+static void CALLBACK task_receive_response( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct request *request = (struct request *)task->object;
-    receive_response( request, TRUE );
+    struct receive_response *r = ctx;
+
+    TRACE("running %p\n", work);
+    receive_response( r->request, TRUE );
+
+    release_object( &r->request->hdr );
+    heap_free( r );
 }
 
 /***********************************************************************
@@ -2830,11 +2784,14 @@ BOOL WINAPI WinHttpReceiveResponse( HINTERNET hrequest, LPVOID reserved )
         struct receive_response *r;
 
         if (!(r = heap_alloc( sizeof(*r) ))) return FALSE;
-        r->hdr.object = &request->hdr;
-        r->hdr.proc   = task_receive_response;
+        r->request = request;
 
         addref_object( &request->hdr );
-        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)r );
+        if ((ret = queue_task( &request->queue, task_receive_response, r )))
+        {
+            release_object( &request->hdr );
+            heap_free( r );
+        }
     }
     else ret = receive_response( request, FALSE );
 
@@ -2876,12 +2833,15 @@ static DWORD query_data_available( struct request *request, DWORD *available, BO
     return ret;
 }
 
-static void task_query_data_available( struct task_header *task )
+static void CALLBACK task_query_data_available( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct request *request = (struct request *)task->object;
-    struct query_data *q = (struct query_data *)task;
+    struct query_data *q = ctx;
 
-    query_data_available( request, q->available, TRUE );
+    TRACE("running %p\n", work);
+    query_data_available( q->request, q->available, TRUE );
+
+    release_object( &q->request->hdr );
+    heap_free( q );
 }
 
 /***********************************************************************
@@ -2911,12 +2871,15 @@ BOOL WINAPI WinHttpQueryDataAvailable( HINTERNET hrequest, LPDWORD available )
         struct query_data *q;
 
         if (!(q = heap_alloc( sizeof(*q) ))) return FALSE;
-        q->hdr.object = &request->hdr;
-        q->hdr.proc   = task_query_data_available;
-        q->available  = available;
+        q->request   = request;
+        q->available = available;
 
         addref_object( &request->hdr );
-        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)q );
+        if ((ret = queue_task( &request->queue, task_query_data_available, q )))
+        {
+            release_object( &request->hdr );
+            heap_free( q );
+        }
     }
     else ret = query_data_available( request, available, FALSE );
 
@@ -2925,12 +2888,15 @@ BOOL WINAPI WinHttpQueryDataAvailable( HINTERNET hrequest, LPDWORD available )
     return !ret;
 }
 
-static void task_read_data( struct task_header *task )
+static void CALLBACK task_read_data( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct request *request = (struct request *)task->object;
-    struct read_data *r = (struct read_data *)task;
+    struct read_data *r = ctx;
+
+    TRACE("running %p\n", work);
+    read_data( r->request, r->buffer, r->to_read, r->read, TRUE );
 
-    read_data( request, r->buffer, r->to_read, r->read, TRUE );
+    release_object( &r->request->hdr );
+    heap_free( r );
 }
 
 /***********************************************************************
@@ -2960,14 +2926,17 @@ BOOL WINAPI WinHttpReadData( HINTERNET hrequest, LPVOID buffer, DWORD to_read, L
         struct read_data *r;
 
         if (!(r = heap_alloc( sizeof(*r) ))) return FALSE;
-        r->hdr.object = &request->hdr;
-        r->hdr.proc   = task_read_data;
-        r->buffer     = buffer;
-        r->to_read    = to_read;
-        r->read       = read;
+        r->request = request;
+        r->buffer  = buffer;
+        r->to_read = to_read;
+        r->read    = read;
 
         addref_object( &request->hdr );
-        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)r );
+        if ((ret = queue_task( &request->queue, task_read_data, r )))
+        {
+            release_object( &request->hdr );
+            heap_free( r );
+        }
     }
     else ret = read_data( request, buffer, to_read, read, FALSE );
 
@@ -2998,12 +2967,15 @@ static DWORD write_data( struct request *request, const void *buffer, DWORD to_w
     return ret;
 }
 
-static void task_write_data( struct task_header *task )
+static void CALLBACK task_write_data( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct request *request = (struct request *)task->object;
-    struct write_data *w = (struct write_data *)task;
+    struct write_data *w = ctx;
 
-    write_data( request, w->buffer, w->to_write, w->written, TRUE );
+    TRACE("running %p\n", work);
+    write_data( w->request, w->buffer, w->to_write, w->written, TRUE );
+
+    release_object( &w->request->hdr );
+    heap_free( w );
 }
 
 /***********************************************************************
@@ -3033,14 +3005,17 @@ BOOL WINAPI WinHttpWriteData( HINTERNET hrequest, LPCVOID buffer, DWORD to_write
         struct write_data *w;
 
         if (!(w = heap_alloc( sizeof(*w) ))) return FALSE;
-        w->hdr.object = &request->hdr;
-        w->hdr.proc   = task_write_data;
-        w->buffer     = buffer;
-        w->to_write   = to_write;
-        w->written    = written;
+        w->request  = request;
+        w->buffer   = buffer;
+        w->to_write = to_write;
+        w->written  = written;
 
         addref_object( &request->hdr );
-        ret = queue_task( &request->hdr, &request->queue, (struct task_header *)w );
+        if ((ret = queue_task( &request->queue, task_write_data, w )))
+        {
+            release_object( &request->hdr );
+            heap_free( w );
+        }
     }
     else ret = write_data( request, buffer, to_write, written, FALSE );
 
@@ -3062,25 +3037,10 @@ static void socket_destroy( struct object_header *hdr )
 
     TRACE("%p\n", socket);
 
-    if (socket->send_q.proc_running)
-    {
-        socket->send_q.proc_running = FALSE;
-        SetEvent( socket->send_q.cancel );
-        return;
-    }
-    if (socket->recv_q.proc_running)
-    {
-        socket->recv_q.proc_running = FALSE;
-        SetEvent( socket->recv_q.cancel );
-        return;
-    }
-    release_object( &socket->request->hdr );
-
-    socket->send_q.cs.DebugInfo->Spare[0] = 0;
-    DeleteCriticalSection( &socket->send_q.cs );
+    if (socket->send_q.pool) CloseThreadpool( socket->send_q.pool );
+    if (socket->recv_q.pool) CloseThreadpool( socket->recv_q.pool );
 
-    socket->recv_q.cs.DebugInfo->Spare[0] = 0;
-    DeleteCriticalSection( &socket->recv_q.cs );
+    release_object( &socket->request->hdr );
     heap_free( socket );
 }
 
@@ -3128,10 +3088,6 @@ HINTERNET WINAPI WinHttpWebSocketCompleteUpgrade( HINTERNET hrequest, DWORD_PTR
     socket->hdr.callback = request->hdr.callback;
     socket->hdr.notify_mask = request->hdr.notify_mask;
     socket->hdr.context = context;
-    InitializeCriticalSection( &socket->send_q.cs );
-    socket->send_q.cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": socket.send_q.cs");
-    InitializeCriticalSection( &socket->recv_q.cs );
-    socket->recv_q.cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": socket.recv_q.cs");
 
     addref_object( &request->hdr );
     socket->request = request;
@@ -3252,12 +3208,15 @@ static DWORD socket_send( struct socket *socket, WINHTTP_WEB_SOCKET_BUFFER_TYPE
     return ret;
 }
 
-static void task_socket_send( struct task_header *task )
+static void CALLBACK task_socket_send( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct socket *socket = (struct socket *)task->object;
-    struct socket_send *s = (struct socket_send *)task;
+    struct socket_send *s = ctx;
 
-    socket_send( socket, s->type, s->buf, s->len, TRUE );
+    TRACE("running %p\n", work);
+    socket_send( s->socket, s->type, s->buf, s->len, TRUE );
+
+    release_object( &s->socket->hdr );
+    heap_free( s );
 }
 
 DWORD WINAPI WinHttpWebSocketSend( HINTERNET hsocket, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, void *buf, DWORD len )
@@ -3291,14 +3250,17 @@ DWORD WINAPI WinHttpWebSocketSend( HINTERNET hsocket, WINHTTP_WEB_SOCKET_BUFFER_
         struct socket_send *s;
 
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
-        s->hdr.object = &socket->hdr;
-        s->hdr.proc   = task_socket_send;
-        s->type       = type;
-        s->buf        = buf;
-        s->len        = len;
+        s->socket = socket;
+        s->type   = type;
+        s->buf    = buf;
+        s->len    = len;
 
         addref_object( &socket->hdr );
-        ret = queue_task( &socket->hdr, &socket->send_q, (struct task_header *)s );
+        if ((ret = queue_task( &socket->send_q, task_socket_send, s )))
+        {
+            release_object( &socket->hdr );
+            heap_free( s );
+        }
     }
     else ret = socket_send( socket, type, buf, len, FALSE );
 
@@ -3404,12 +3366,15 @@ static DWORD socket_receive( struct socket *socket, void *buf, DWORD len, DWORD
     return ret;
 }
 
-static void task_socket_receive( struct task_header *task )
+static void CALLBACK task_socket_receive( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct socket *socket = (struct socket *)task->object;
-    struct socket_receive *r = (struct socket_receive *)task;
+    struct socket_receive *r = ctx;
+
+    TRACE("running %p\n", work);
+    socket_receive( r->socket, r->buf, r->len, NULL, NULL, TRUE );
 
-    socket_receive( socket, r->buf, r->len, NULL, NULL, TRUE );
+    release_object( &r->socket->hdr );
+    heap_free( r );
 }
 
 DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, DWORD *ret_len,
@@ -3439,13 +3404,16 @@ DWORD WINAPI WinHttpWebSocketReceive( HINTERNET hsocket, void *buf, DWORD len, D
         struct socket_receive *r;
 
         if (!(r = heap_alloc( sizeof(*r) ))) return FALSE;
-        r->hdr.object = &socket->hdr;
-        r->hdr.proc   = task_socket_receive;
-        r->buf        = buf;
-        r->len        = len;
+        r->socket = socket;
+        r->buf    = buf;
+        r->len    = len;
 
         addref_object( &socket->hdr );
-        ret = queue_task( &socket->hdr, &socket->recv_q, (struct task_header *)r );
+        if ((ret = queue_task( &socket->recv_q, task_socket_receive, r )))
+        {
+            release_object( &socket->hdr );
+            heap_free( r );
+        }
     }
     else ret = socket_receive( socket, buf, len, ret_len, ret_type, FALSE );
 
@@ -3477,12 +3445,15 @@ static DWORD socket_shutdown( struct socket *socket, USHORT status, const void *
     return ret;
 }
 
-static void task_socket_shutdown( struct task_header *task )
+static void CALLBACK task_socket_shutdown( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct socket *socket = (struct socket *)task->object;
-    struct socket_shutdown *s = (struct socket_shutdown *)task;
+    struct socket_shutdown *s = ctx;
 
-    socket_shutdown( socket, s->status, s->reason, s->len, TRUE );
+    socket_shutdown( s->socket, s->status, s->reason, s->len, TRUE );
+
+    TRACE("running %p\n", work);
+    release_object( &s->socket->hdr );
+    heap_free( s );
 }
 
 DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
@@ -3511,14 +3482,17 @@ DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *r
         struct socket_shutdown *s;
 
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
-        s->hdr.object = &socket->hdr;
-        s->hdr.proc   = task_socket_shutdown;
-        s->status     = status;
-        s->reason     = reason;
-        s->len        = len;
+        s->socket = socket;
+        s->status = status;
+        s->reason = reason;
+        s->len    = len;
 
         addref_object( &socket->hdr );
-        ret = queue_task( &socket->hdr, &socket->send_q, (struct task_header *)s );
+        if ((ret = queue_task( &socket->send_q, task_socket_shutdown, s )))
+        {
+            release_object( &socket->hdr );
+            heap_free( s );
+        }
     }
     else ret = socket_shutdown( socket, status, reason, len, FALSE );
 
@@ -3577,12 +3551,15 @@ static DWORD socket_close( struct socket *socket, USHORT status, const void *rea
     return ret;
 }
 
-static void task_socket_close( struct task_header *task )
+static void CALLBACK task_socket_close( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
 {
-    struct socket *socket = (struct socket *)task->object;
-    struct socket_shutdown *s = (struct socket_shutdown *)task;
+    struct socket_shutdown *s = ctx;
+
+    socket_close( s->socket, s->status, s->reason, s->len, TRUE );
 
-    socket_close( socket, s->status, s->reason, s->len, TRUE );
+    TRACE("running %p\n", work);
+    release_object( &s->socket->hdr );
+    heap_free( s );
 }
 
 DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reason, DWORD len )
@@ -3611,14 +3588,17 @@ DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reas
         struct socket_shutdown *s;
 
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
-        s->hdr.object = &socket->hdr;
-        s->hdr.proc   = task_socket_close;
-        s->status     = status;
-        s->reason     = reason;
-        s->len        = len;
+        s->socket = socket;
+        s->status = status;
+        s->reason = reason;
+        s->len    = len;
 
         addref_object( &socket->hdr );
-        ret = queue_task( &socket->hdr, &socket->recv_q, (struct task_header *)s );
+        if ((ret = queue_task( &socket->recv_q, task_socket_close, s )))
+        {
+            release_object( &socket->hdr );
+            heap_free( s );
+        }
     }
     else ret = socket_close( socket, status, reason, len, FALSE );
 
diff --git a/dlls/winhttp/session.c b/dlls/winhttp/session.c
index 228eb646ae0..f3ab8c9b959 100644
--- a/dlls/winhttp/session.c
+++ b/dlls/winhttp/session.c
@@ -578,13 +578,7 @@ static void request_destroy( struct object_header *hdr )
 
     TRACE("%p\n", request);
 
-    if (request->queue.proc_running)
-    {
-        /* Signal to the task proc to quit. It will call this again when it does. */
-        request->queue.proc_running = FALSE;
-        SetEvent( request->queue.cancel );
-        return;
-    }
+    if (request->queue.pool) CloseThreadpool( request->queue.pool );
     release_object( &request->connect->hdr );
 
     if (request->cred_handle_initialized) FreeCredentialsHandle( &request->cred_handle );
@@ -614,8 +608,6 @@ static void request_destroy( struct object_header *hdr )
         }
     }
 
-    request->queue.cs.DebugInfo->Spare[0] = 0;
-    DeleteCriticalSection( &request->queue.cs );
     heap_free( request );
 }
 
@@ -1120,8 +1112,6 @@ HINTERNET WINAPI WinHttpOpenRequest( HINTERNET hconnect, LPCWSTR verb, LPCWSTR o
     request->hdr.notify_mask = connect->hdr.notify_mask;
     request->hdr.context = connect->hdr.context;
     request->hdr.redirect_policy = connect->hdr.redirect_policy;
-    InitializeCriticalSection( &request->queue.cs );
-    request->queue.cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": request.queue.cs");
 
     addref_object( &connect->hdr );
     request->connect = connect;
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 4a943750061..ac7e9ff09b5 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -157,12 +157,8 @@ struct authinfo
 
 struct queue
 {
-    struct object_header *object;
-    CRITICAL_SECTION cs;
-    BOOL proc_running;
-    HANDLE wait;
-    HANDLE cancel;
-    struct list tasks;
+    TP_POOL *pool;
+    TP_CALLBACK_ENVIRON env;
 };
 
 enum request_flags
@@ -252,16 +248,9 @@ struct socket
     DWORD reason_len;
 };
 
-struct task_header
-{
-    struct list entry;
-    struct object_header *object;
-    void (*proc)( struct task_header * );
-};
-
 struct send_request
 {
-    struct task_header hdr;
+    struct request *request;
     WCHAR *headers;
     DWORD headers_len;
     void *optional;
@@ -272,18 +261,18 @@ struct send_request
 
 struct receive_response
 {
-    struct task_header hdr;
+    struct request *request;
 };
 
 struct query_data
 {
-    struct task_header hdr;
+    struct request *request;
     DWORD *available;
 };
 
 struct read_data
 {
-    struct task_header hdr;
+    struct request *request;
     void *buffer;
     DWORD to_read;
     DWORD *read;
@@ -291,7 +280,7 @@ struct read_data
 
 struct write_data
 {
-    struct task_header hdr;
+    struct request *request;
     const void *buffer;
     DWORD to_write;
     DWORD *written;
@@ -299,7 +288,7 @@ struct write_data
 
 struct socket_send
 {
-    struct task_header hdr;
+    struct socket *socket;
     WINHTTP_WEB_SOCKET_BUFFER_TYPE type;
     const void *buf;
     DWORD len;
@@ -307,14 +296,14 @@ struct socket_send
 
 struct socket_receive
 {
-    struct task_header hdr;
+    struct socket *socket;
     void *buf;
     DWORD len;
 };
 
 struct socket_shutdown
 {
-    struct task_header hdr;
+    struct socket *socket;
     USHORT status;
     const void *reason;
     DWORD len;
From 7b7fdb8585b78fcb9ead0b65472196c0fffe23c8 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 29 Jun 2020 15:46:11 +0200
Subject: [PATCH] winhttp: Copy the reason buffer.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 8 ++++----
 dlls/winhttp/tests/winhttp.c   | 6 ++++++
 dlls/winhttp/winhttp_private.h | 4 ++--
 3 files changed, 12 insertions(+), 6 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index bc3d365f7cd..06588d6f606 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3463,7 +3463,7 @@ DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *r
 
     TRACE("%p, %u, %p, %u\n", hsocket, status, reason, len);
 
-    if (len && !reason) return ERROR_INVALID_PARAMETER;
+    if ((len && !reason) || len > sizeof(socket->reason)) return ERROR_INVALID_PARAMETER;
 
     if (!(socket = (struct socket *)grab_object( hsocket ))) return ERROR_INVALID_HANDLE;
     if (socket->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
@@ -3484,7 +3484,7 @@ DWORD WINAPI WinHttpWebSocketShutdown( HINTERNET hsocket, USHORT status, void *r
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
         s->socket = socket;
         s->status = status;
-        s->reason = reason;
+        memcpy( s->reason, reason, len );
         s->len    = len;
 
         addref_object( &socket->hdr );
@@ -3569,7 +3569,7 @@ DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reas
 
     TRACE("%p, %u, %p, %u\n", hsocket, status, reason, len);
 
-    if (len && !reason) return ERROR_INVALID_PARAMETER;
+    if ((len && !reason) || len > sizeof(socket->reason)) return ERROR_INVALID_PARAMETER;
 
     if (!(socket = (struct socket *)grab_object( hsocket ))) return ERROR_INVALID_HANDLE;
     if (socket->hdr.type != WINHTTP_HANDLE_TYPE_SOCKET)
@@ -3590,7 +3590,7 @@ DWORD WINAPI WinHttpWebSocketClose( HINTERNET hsocket, USHORT status, void *reas
         if (!(s = heap_alloc( sizeof(*s) ))) return FALSE;
         s->socket = socket;
         s->status = status;
-        s->reason = reason;
+        memcpy( s->reason, reason, len );
         s->len    = len;
 
         addref_object( &socket->hdr );
diff --git a/dlls/winhttp/tests/winhttp.c b/dlls/winhttp/tests/winhttp.c
index 12f5136973f..84063fdc82a 100644
--- a/dlls/winhttp/tests/winhttp.c
+++ b/dlls/winhttp/tests/winhttp.c
@@ -3356,6 +3356,9 @@ static void test_websocket(int port)
     error = pWinHttpWebSocketShutdown(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, NULL, 1);
     ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
 
+    error = pWinHttpWebSocketShutdown(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, buf, sizeof(buf));
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
     error = pWinHttpWebSocketShutdown(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, (void *)"success",
                                       sizeof("success"));
     ok(!error, "got %u\n", error);
@@ -3363,6 +3366,9 @@ static void test_websocket(int port)
     error = pWinHttpWebSocketClose(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, NULL, 1);
     ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
 
+    error = pWinHttpWebSocketClose(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, buf, sizeof(buf));
+    ok(error == ERROR_INVALID_PARAMETER, "got %u\n", error);
+
     error = pWinHttpWebSocketClose(socket, WINHTTP_WEB_SOCKET_SUCCESS_CLOSE_STATUS, (void *)"success2",
                                    sizeof("success2"));
     ok(!error, "got %u\n", error);
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index ac7e9ff09b5..9d0b9c308ab 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -244,7 +244,7 @@ struct socket
     enum socket_opcode opcode;
     DWORD read_size;
     USHORT status;
-    char reason[128];
+    char reason[123];
     DWORD reason_len;
 };
 
@@ -305,7 +305,7 @@ struct socket_shutdown
 {
     struct socket *socket;
     USHORT status;
-    const void *reason;
+    char reason[123];
     DWORD len;
 };
 
From dffd8e86475a8fd034c3167b576551ff7fd02f5b Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 29 Jun 2020 15:46:12 +0200
Subject: [PATCH] winhttp: Add support for ping and pong messages.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c | 177 +++++++++++++++++++++++++++++++----------
 1 file changed, 136 insertions(+), 41 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 06588d6f606..7cb07b5c107 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -3112,29 +3112,18 @@ static DWORD send_bytes( struct netconn *netconn, char *bytes, int len )
     return (count == len) ? ERROR_SUCCESS : ERROR_INTERNAL_ERROR;
 }
 
-static enum socket_opcode map_buffer_type( WINHTTP_WEB_SOCKET_BUFFER_TYPE type )
-{
-    switch (type)
-    {
-    case WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE:   return SOCKET_OPCODE_TEXT;
-    case WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE: return SOCKET_OPCODE_BINARY;
-    case WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE:          return SOCKET_OPCODE_CLOSE;
-    default:
-        FIXME("buffer type %u not supported\n", type);
-        return SOCKET_OPCODE_INVALID;
-    }
-}
-
 #define FIN_BIT (1 << 7)
 #define MASK_BIT (1 << 7)
 #define RESERVED_BIT (7 << 4)
+#define CONTROL_BIT (1 << 3)
 
-static DWORD send_frame( struct netconn *netconn, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, USHORT status, const char *buf,
+static DWORD send_frame( struct netconn *netconn, enum socket_opcode opcode, USHORT status, const char *buf,
                          DWORD buflen, BOOL final )
 {
     DWORD i = 0, j, ret, offset = 2, len = buflen;
-    enum socket_opcode opcode = map_buffer_type( type );
-    char hdr[14], byte, *mask;
+    char hdr[14], byte, *mask = NULL;
+
+    TRACE("sending %02x frame\n", opcode);
 
     if (opcode == SOCKET_OPCODE_CLOSE) len += sizeof(status);
 
@@ -3159,9 +3148,14 @@ static DWORD send_frame( struct netconn *netconn, WINHTTP_WEB_SOCKET_BUFFER_TYPE
         hdr[9] = len & 0xff;
         offset += 8;
     }
-    mask = &hdr[offset];
-    RtlGenRandom( mask, 4 );
-    if ((ret = send_bytes( netconn, hdr, offset + 4 ))) return ret;
+
+    if ((ret = send_bytes( netconn, hdr, offset ))) return ret;
+    if (len)
+    {
+        mask = &hdr[offset];
+        RtlGenRandom( mask, 4 );
+        if ((ret = send_bytes( netconn, mask, 4 ))) return ret;
+    }
 
     if (opcode == SOCKET_OPCODE_CLOSE) /* prepend status code */
     {
@@ -3181,12 +3175,26 @@ static DWORD send_frame( struct netconn *netconn, WINHTTP_WEB_SOCKET_BUFFER_TYPE
     return ERROR_SUCCESS;
 }
 
+static enum socket_opcode map_buffer_type( WINHTTP_WEB_SOCKET_BUFFER_TYPE type )
+{
+    switch (type)
+    {
+    case WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE:   return SOCKET_OPCODE_TEXT;
+    case WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE: return SOCKET_OPCODE_BINARY;
+    case WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE:          return SOCKET_OPCODE_CLOSE;
+    default:
+        FIXME("buffer type %u not supported\n", type);
+        return SOCKET_OPCODE_INVALID;
+    }
+}
+
 static DWORD socket_send( struct socket *socket, WINHTTP_WEB_SOCKET_BUFFER_TYPE type, const void *buf, DWORD len,
                           BOOL async )
 {
+    enum socket_opcode opcode = map_buffer_type( type );
     DWORD ret;
 
-    ret = send_frame( socket->request->netconn, type, 0, buf, len, TRUE );
+    ret = send_frame( socket->request->netconn, opcode, 0, buf, len, TRUE );
     if (async)
     {
         if (!ret)
@@ -3276,24 +3284,19 @@ static DWORD receive_bytes( struct netconn *netconn, char *buf, DWORD len, DWORD
     return ERROR_SUCCESS;
 }
 
-static WINHTTP_WEB_SOCKET_BUFFER_TYPE map_opcode( enum socket_opcode opcode, BOOL fragment )
+static BOOL is_supported_opcode( enum socket_opcode opcode )
 {
     switch (opcode)
     {
     case SOCKET_OPCODE_TEXT:
-        if (fragment) return WINHTTP_WEB_SOCKET_UTF8_FRAGMENT_BUFFER_TYPE;
-        return WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE;
-
     case SOCKET_OPCODE_BINARY:
-        if (fragment) return WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE;
-        return WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE;
-
     case SOCKET_OPCODE_CLOSE:
-        return WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE;
-
+    case SOCKET_OPCODE_PING:
+    case SOCKET_OPCODE_PONG:
+        return TRUE;
     default:
-        FIXME("opcode %u not handled\n", opcode);
-        return ~0u;
+        FIXME( "opcode %02x not handled\n", opcode );
+        return FALSE;
     }
 }
 
@@ -3303,11 +3306,12 @@ static DWORD receive_frame( struct netconn *netconn, DWORD *ret_len, enum socket
     char hdr[2];
 
     if ((ret = receive_bytes( netconn, hdr, sizeof(hdr), &count ))) return ret;
-    if ((hdr[0] & RESERVED_BIT) || (hdr[1] & MASK_BIT) || (map_opcode( hdr[0] & 0xf, FALSE ) == ~0u))
+    if ((hdr[0] & RESERVED_BIT) || (hdr[1] & MASK_BIT) || !is_supported_opcode( hdr[0] & 0xf ))
     {
         return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
     }
     *opcode = hdr[0] & 0xf;
+    TRACE("received %02x frame\n", *opcode);
 
     len = hdr[1] & ~MASK_BIT;
     if (len == 126)
@@ -3328,13 +3332,109 @@ static DWORD receive_frame( struct netconn *netconn, DWORD *ret_len, enum socket
     return ERROR_SUCCESS;
 }
 
+static void CALLBACK task_socket_send_pong( TP_CALLBACK_INSTANCE *instance, void *ctx, TP_WORK *work )
+{
+    struct socket_send *s = ctx;
+
+    TRACE("running %p\n", work);
+    send_frame( s->socket->request->netconn, SOCKET_OPCODE_PONG, 0, NULL, 0, TRUE );
+
+    release_object( &s->socket->hdr );
+    heap_free( s );
+}
+
+static DWORD socket_send_pong( struct socket *socket )
+{
+    if (socket->request->connect->hdr.flags & WINHTTP_FLAG_ASYNC)
+    {
+        struct socket_send *s;
+        DWORD ret;
+
+        if (!(s = heap_alloc( sizeof(*s) ))) return ERROR_OUTOFMEMORY;
+        s->socket = socket;
+
+        addref_object( &socket->hdr );
+        if ((ret = queue_task( &socket->send_q, task_socket_send_pong, s )))
+        {
+            release_object( &socket->hdr );
+            heap_free( s );
+        }
+        return ret;
+    }
+    return send_frame( socket->request->netconn, SOCKET_OPCODE_PONG, 0, NULL, 0, TRUE );
+}
+
+static DWORD socket_drain( struct socket *socket )
+{
+    struct netconn *netconn = socket->request->netconn;
+    DWORD ret, count;
+
+    while (socket->read_size)
+    {
+        char buf[1024];
+        if ((ret = receive_bytes( netconn, buf, min(socket->read_size, sizeof(buf)), &count ))) return ret;
+        socket->read_size -= count;
+    }
+    return ERROR_SUCCESS;
+}
+
+static DWORD handle_control_frame( struct socket *socket )
+{
+    switch (socket->opcode)
+    {
+    case SOCKET_OPCODE_PING:
+        return socket_send_pong( socket );
+
+    case SOCKET_OPCODE_PONG:
+        return socket_drain( socket );
+
+    default:
+        ERR("unhandled control opcode %02x\n", socket->opcode);
+        return ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
+    }
+
+    return ERROR_SUCCESS;
+}
+
+static WINHTTP_WEB_SOCKET_BUFFER_TYPE map_opcode( enum socket_opcode opcode, BOOL fragment )
+{
+    switch (opcode)
+    {
+    case SOCKET_OPCODE_TEXT:
+        if (fragment) return WINHTTP_WEB_SOCKET_UTF8_FRAGMENT_BUFFER_TYPE;
+        return WINHTTP_WEB_SOCKET_UTF8_MESSAGE_BUFFER_TYPE;
+
+    case SOCKET_OPCODE_BINARY:
+        if (fragment) return WINHTTP_WEB_SOCKET_BINARY_FRAGMENT_BUFFER_TYPE;
+        return WINHTTP_WEB_SOCKET_BINARY_MESSAGE_BUFFER_TYPE;
+
+    case SOCKET_OPCODE_CLOSE:
+        return WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE;
+
+    default:
+        FIXME("opcode %02x not handled\n", opcode);
+        return ~0u;
+    }
+}
+
 static DWORD socket_receive( struct socket *socket, void *buf, DWORD len, DWORD *ret_len,
                              WINHTTP_WEB_SOCKET_BUFFER_TYPE *ret_type, BOOL async )
 {
     struct netconn *netconn = socket->request->netconn;
     DWORD count, ret = ERROR_SUCCESS;
 
-    if (!socket->read_size) ret = receive_frame( netconn, &socket->read_size, &socket->opcode );
+    if (!socket->read_size)
+    {
+        for (;;)
+        {
+            if (!(ret = receive_frame( netconn, &socket->read_size, &socket->opcode )))
+            {
+                if (!(socket->opcode & CONTROL_BIT) || (ret = handle_control_frame( socket ))) break;
+            }
+            else if (ret == WSAETIMEDOUT) ret = socket_send_pong( socket );
+            if (ret) break;
+        }
+    }
     if (!ret) ret = receive_bytes( netconn, buf, min(len, socket->read_size), &count );
     if (!ret)
     {
@@ -3426,7 +3526,7 @@ static DWORD socket_shutdown( struct socket *socket, USHORT status, const void *
     struct netconn *netconn = socket->request->netconn;
     DWORD ret;
 
-    if (!(ret = send_frame( netconn, WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE, status, reason, len, TRUE )))
+    if (!(ret = send_frame( netconn, SOCKET_OPCODE_CLOSE, status, reason, len, TRUE )))
     {
         socket->state = SOCKET_STATE_SHUTDOWN;
     }
@@ -3505,16 +3605,11 @@ static DWORD socket_close( struct socket *socket, USHORT status, const void *rea
     struct netconn *netconn = socket->request->netconn;
     DWORD ret, count;
 
-    while (socket->read_size) /* drain any pending data */
-    {
-        char buf[1024];
-        if ((ret = receive_bytes( netconn, buf, min(socket->read_size, sizeof(buf)), &count ))) goto done;
-        socket->read_size -= count;
-    }
+    if ((ret = socket_drain( socket ))) goto done;
 
     if (socket->state < SOCKET_STATE_SHUTDOWN)
     {
-        if ((ret = send_frame( netconn, WINHTTP_WEB_SOCKET_CLOSE_BUFFER_TYPE, status, reason, len, TRUE ))) goto done;
+        if ((ret = send_frame( netconn, SOCKET_OPCODE_CLOSE, status, reason, len, TRUE ))) goto done;
         socket->state = SOCKET_STATE_SHUTDOWN;
     }
 
From 97f9dc7ff46a161468dcf7866381db23474a1031 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Mon, 29 Jun 2020 15:46:13 +0200
Subject: [PATCH] winhttp: Stop the send queue before sending the close
 message.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/winhttp/request.c         | 14 ++++++++++++--
 dlls/winhttp/session.c         |  2 +-
 dlls/winhttp/winhttp_private.h |  1 +
 3 files changed, 14 insertions(+), 3 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index 7cb07b5c107..e31803ccfed 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -138,6 +138,14 @@ static DWORD start_queue( struct queue *queue )
     return ERROR_SUCCESS;
 }
 
+void stop_queue( struct queue *queue )
+{
+    if (!queue->pool) return;
+    CloseThreadpool( queue->pool );
+    queue->pool = NULL;
+    TRACE("stopped %p\n", queue);
+}
+
 static DWORD queue_task( struct queue *queue, PTP_WORK_CALLBACK task, void *ctx )
 {
     TP_WORK *work;
@@ -3037,8 +3045,8 @@ static void socket_destroy( struct object_header *hdr )
 
     TRACE("%p\n", socket);
 
-    if (socket->send_q.pool) CloseThreadpool( socket->send_q.pool );
-    if (socket->recv_q.pool) CloseThreadpool( socket->recv_q.pool );
+    stop_queue( &socket->send_q );
+    stop_queue( &socket->recv_q );
 
     release_object( &socket->request->hdr );
     heap_free( socket );
@@ -3526,6 +3534,7 @@ static DWORD socket_shutdown( struct socket *socket, USHORT status, const void *
     struct netconn *netconn = socket->request->netconn;
     DWORD ret;
 
+    stop_queue( &socket->send_q );
     if (!(ret = send_frame( netconn, SOCKET_OPCODE_CLOSE, status, reason, len, TRUE )))
     {
         socket->state = SOCKET_STATE_SHUTDOWN;
@@ -3609,6 +3618,7 @@ static DWORD socket_close( struct socket *socket, USHORT status, const void *rea
 
     if (socket->state < SOCKET_STATE_SHUTDOWN)
     {
+        stop_queue( &socket->send_q );
         if ((ret = send_frame( netconn, SOCKET_OPCODE_CLOSE, status, reason, len, TRUE ))) goto done;
         socket->state = SOCKET_STATE_SHUTDOWN;
     }
diff --git a/dlls/winhttp/session.c b/dlls/winhttp/session.c
index f3ab8c9b959..080837eb1ed 100644
--- a/dlls/winhttp/session.c
+++ b/dlls/winhttp/session.c
@@ -578,7 +578,7 @@ static void request_destroy( struct object_header *hdr )
 
     TRACE("%p\n", request);
 
-    if (request->queue.pool) CloseThreadpool( request->queue.pool );
+    stop_queue( &request->queue );
     release_object( &request->connect->hdr );
 
     if (request->cred_handle_initialized) FreeCredentialsHandle( &request->cred_handle );
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 9d0b9c308ab..23aba00780e 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -317,6 +317,7 @@ BOOL free_handle( HINTERNET ) DECLSPEC_HIDDEN;
 
 void send_callback( struct object_header *, DWORD, LPVOID, DWORD ) DECLSPEC_HIDDEN;
 void close_connection( struct request * ) DECLSPEC_HIDDEN;
+void stop_queue( struct queue * ) DECLSPEC_HIDDEN;
 
 void netconn_close( struct netconn * ) DECLSPEC_HIDDEN;
 DWORD netconn_create( struct hostdata *, const struct sockaddr_storage *, int, struct netconn ** ) DECLSPEC_HIDDEN;

From: Owen Rudge <orudge@codeweavers.com>
Subject: [PATCH 1/2] winhttp/tests: Add tests for WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS.
Message-Id: <184c7832-c2a6-7ff2-8333-bd25662597df@codeweavers.com>
Date: Fri, 3 Jul 2020 10:21:37 +0100

Signed-off-by: Owen Rudge <orudge@codeweavers.com>
---
  dlls/winhttp/tests/winhttp.c | 52 ++++++++++++++++++++++++++++++++++++
  1 file changed, 52 insertions(+)

diff --git a/dlls/winhttp/tests/winhttp.c b/dlls/winhttp/tests/winhttp.c
index 84063fdc82a..79d700d4a12 100644
--- a/dlls/winhttp/tests/winhttp.c
+++ b/dlls/winhttp/tests/winhttp.c
@@ -5076,6 +5076,57 @@ done:
     if (ses) WinHttpCloseHandle( ses );
 }
 
+static void test_max_http_automatic_redirects (void)
+{
+    HINTERNET session, request, connection;
+    DWORD max_redirects, err;
+    BOOL ret;
+
+    session = WinHttpOpen(L"winetest", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
+        WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
+    ok(session != NULL, "WinHttpOpen failed to open session.\n");
+
+    connection = WinHttpConnect (session, L"test.winehq.org", INTERNET_DEFAULT_HTTP_PORT, 0);
+    ok(connection != NULL, "WinHttpConnect failed to open a connection, error: %u.\n", GetLastError());
+
+    /* Test with 2 redirects (page will try to redirect 3 times) */
+    request = WinHttpOpenRequest(connection, L"GET", L"tests/redirecttest.php?max=3", NULL, WINHTTP_NO_REFERER,
+        WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_BYPASS_PROXY_CACHE);
+    if (request == NULL && GetLastError() == ERROR_WINHTTP_NAME_NOT_RESOLVED)
+    {
+        skip("Network unreachable, skipping.\n");
+        goto done;
+    }
+    ok(request != NULL, "WinHttpOpenRequest failed to open a request, error: %u.\n", GetLastError());
+    if (!request) goto done;
+
+    max_redirects = 2;
+    ret = WinHttpSetOption(request, WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS, &max_redirects, sizeof(max_redirects));
+    todo_wine ok(ret, "WinHttpSetOption failed: %u\n", GetLastError());
+
+    ret = WinHttpSendRequest(request, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);
+    err = GetLastError();
+    if (!ret && (err == ERROR_WINHTTP_CANNOT_CONNECT || err == ERROR_WINHTTP_TIMEOUT))
+    {
+        skip("connection failed, skipping\n");
+        goto done;
+    }
+    ok(ret == TRUE, "WinHttpSendRequest failed: %u\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = WinHttpReceiveResponse(request, NULL);
+    todo_wine ok(!ret, "WinHttpReceiveResponse succeeded, expected failure\n");
+    todo_wine ok(GetLastError() == ERROR_WINHTTP_REDIRECT_FAILED, "Expected ERROR_WINHTTP_REDIRECT_FAILED, got %u.\n", GetLastError());
+
+ done:
+    ret = WinHttpCloseHandle(request);
+    ok(ret == TRUE, "WinHttpCloseHandle failed on closing request, got %d.\n", ret);
+    ret = WinHttpCloseHandle(connection);
+    ok(ret == TRUE, "WinHttpCloseHandle failed on closing connection, got %d.\n", ret);
+    ret = WinHttpCloseHandle(session);
+    ok(ret == TRUE, "WinHttpCloseHandle failed on closing session, got %d.\n", ret);
+}
+
 START_TEST (winhttp)
 {
     struct server_info si;
@@ -5108,6 +5159,7 @@ START_TEST (winhttp)
     test_WinHttpGetIEProxyConfigForCurrentUser();
     test_WinHttpGetProxyForUrl();
     test_chunked_read();
+    test_max_http_automatic_redirects();
 
     si.event = CreateEventW(NULL, 0, 0, NULL);
     si.port = 7532;

From: Owen Rudge <orudge@codeweavers.com>
Subject: [PATCH 2/2] winhttp: Implement WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS.
Message-Id: <a7511ce1-a6ad-f0b4-f8b6-a719cb518ef9@codeweavers.com>
Date: Fri, 3 Jul 2020 10:21:40 +0100

Signed-off-by: Owen Rudge <orudge@codeweavers.com>
---
  dlls/winhttp/request.c         |  2 ++
  dlls/winhttp/session.c         | 17 +++++++++++++++++
  dlls/winhttp/tests/winhttp.c   |  6 +++---
  dlls/winhttp/winhttp_private.h |  2 ++
  4 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/dlls/winhttp/request.c b/dlls/winhttp/request.c
index e31803ccfed..31296cd02ba 100644
--- a/dlls/winhttp/request.c
+++ b/dlls/winhttp/request.c
@@ -2720,6 +2720,8 @@ static DWORD receive_response( struct request *request, BOOL async )
             if (request->hdr.disable_flags & WINHTTP_DISABLE_REDIRECTS ||
                 request->hdr.redirect_policy == WINHTTP_OPTION_REDIRECT_POLICY_NEVER) break;
 
+            if (++request->redirect_count > request->max_redirects) return ERROR_WINHTTP_REDIRECT_FAILED;
+
             if ((ret = handle_redirect( request, status ))) break;
 
             /* recurse synchronously */
diff --git a/dlls/winhttp/session.c b/dlls/winhttp/session.c
index 080837eb1ed..319066db55b 100644
--- a/dlls/winhttp/session.c
+++ b/dlls/winhttp/session.c
@@ -820,6 +820,11 @@ static BOOL request_query_option( struct object_header *hdr, DWORD option, void
         str_to_buffer( buffer, request->connect->session->proxy_password, buflen );
         return TRUE;
 
+    case WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS:
+        *(DWORD *)buffer = request->max_redirects;
+        *buflen = sizeof(DWORD);
+        return TRUE;
+
     default:
         FIXME("unimplemented option %u\n", option);
         SetLastError( ERROR_INVALID_PARAMETER );
@@ -1028,6 +1033,17 @@ static BOOL request_set_option( struct object_header *hdr, DWORD option, void *b
         FIXME("WINHTTP_OPTION_CONNECT_RETRIES\n");
         return TRUE;
 
+    case WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS:
+        if (buflen == sizeof(DWORD))
+        {
+            request->max_redirects = *(DWORD *)buffer;
+            SetLastError(NO_ERROR);
+            return TRUE;
+        }
+
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+
     default:
         FIXME("unimplemented option %u\n", option);
         SetLastError( ERROR_WINHTTP_INVALID_OPTION );
@@ -1121,6 +1137,7 @@ HINTERNET WINAPI WinHttpOpenRequest( HINTERNET hconnect, LPCWSTR verb, LPCWSTR o
     request->send_timeout = connect->session->send_timeout;
     request->receive_timeout = connect->session->receive_timeout;
     request->receive_response_timeout = connect->session->receive_response_timeout;
+    request->max_redirects = 10;
 
     if (!verb || !verb[0]) verb = L"GET";
     if (!(request->verb = strdupW( verb ))) goto end;
diff --git a/dlls/winhttp/tests/winhttp.c b/dlls/winhttp/tests/winhttp.c
index 79d700d4a12..5379640d5fc 100644
--- a/dlls/winhttp/tests/winhttp.c
+++ b/dlls/winhttp/tests/winhttp.c
@@ -5102,7 +5102,7 @@ static void test_max_http_automatic_redirects (void)
 
     max_redirects = 2;
     ret = WinHttpSetOption(request, WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS, &max_redirects, sizeof(max_redirects));
-    todo_wine ok(ret, "WinHttpSetOption failed: %u\n", GetLastError());
+    ok(ret, "WinHttpSetOption failed: %u\n", GetLastError());
 
     ret = WinHttpSendRequest(request, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);
     err = GetLastError();
@@ -5115,8 +5115,8 @@ static void test_max_http_automatic_redirects (void)
 
     SetLastError(0xdeadbeef);
     ret = WinHttpReceiveResponse(request, NULL);
-    todo_wine ok(!ret, "WinHttpReceiveResponse succeeded, expected failure\n");
-    todo_wine ok(GetLastError() == ERROR_WINHTTP_REDIRECT_FAILED, "Expected ERROR_WINHTTP_REDIRECT_FAILED, got %u.\n", GetLastError());
+    ok(!ret, "WinHttpReceiveResponse succeeded, expected failure\n");
+    ok(GetLastError() == ERROR_WINHTTP_REDIRECT_FAILED, "Expected ERROR_WINHTTP_REDIRECT_FAILED, got %u.\n", GetLastError());
 
  done:
     ret = WinHttpCloseHandle(request);
diff --git a/dlls/winhttp/winhttp_private.h b/dlls/winhttp/winhttp_private.h
index 23aba00780e..e279e58a5fe 100644
--- a/dlls/winhttp/winhttp_private.h
+++ b/dlls/winhttp/winhttp_private.h
@@ -189,6 +189,8 @@ struct request
     int send_timeout;
     int receive_timeout;
     int receive_response_timeout;
+    DWORD max_redirects;
+    DWORD redirect_count; /* total number of redirects during this request */
     WCHAR *status_text;
     DWORD content_length; /* total number of bytes to be read */
     DWORD content_read;   /* bytes read so far */

From: Serge Gautherie <winehq-git_serge_180711@gautherie.fr>
Subject: [PATCH] wininet: Increase user size to 'UNLEN + 1' in create_cookie_url().
Message-Id: <20200701143418.2768-1-winehq-git_serge_180711@gautherie.fr>
Date: Wed,  1 Jul 2020 16:34:18 +0200

Signed-off-by: Serge Gautherie <winehq-git_serge_180711@gautherie.fr>
---
 dlls/wininet/cookie.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/wininet/cookie.c b/dlls/wininet/cookie.c
index b5f779b..4d0967b 100644
--- a/dlls/wininet/cookie.c
+++ b/dlls/wininet/cookie.c
@@ -147,7 +147,7 @@ static cookie_domain_t *get_cookie_domain(substr_t domain, BOOL create)
 
 static WCHAR *create_cookie_url(substr_t domain, substr_t path, substr_t *ret_path)
 {
-    WCHAR user[UNLEN], *p, *url;
+    WCHAR user[UNLEN + 1], *p, *url;
     DWORD len, user_len, i;
 
     static const WCHAR cookie_prefix[] = {'C','o','o','k','i','e',':'};

-- 
2.10.0.windows.1

From 3e0369970d90b5ca42d2e1f7dc5810fec5477587 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Thu, 2 Jul 2020 10:23:27 +0200
Subject: [PATCH] iphlpapi: Return gateway address 0.0.0.0/255.255.255.255 from
 GetAdaptersInfo if it's not set.

Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/iphlpapi/iphlpapi_main.c  | 2 ++
 dlls/iphlpapi/tests/iphlpapi.c | 9 ++++++---
 2 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/dlls/iphlpapi/iphlpapi_main.c b/dlls/iphlpapi/iphlpapi_main.c
index ff9d0d3a536..c0390862295 100644
--- a/dlls/iphlpapi/iphlpapi_main.c
+++ b/dlls/iphlpapi/iphlpapi_main.c
@@ -742,6 +742,8 @@ DWORD WINAPI GetAdaptersInfo(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen)
               }
               /* Find first router through this interface, which we'll assume
                * is the default gateway for this adapter */
+              strcpy(ptr->GatewayList.IpAddress.String, "0.0.0.0");
+              strcpy(ptr->GatewayList.IpMask.String, "255.255.255.255");
               for (i = 0; i < routeTable->dwNumEntries; i++)
                 if (routeTable->table[i].dwForwardIfIndex == ptr->Index
                  && routeTable->table[i].u1.ForwardType ==
diff --git a/dlls/iphlpapi/tests/iphlpapi.c b/dlls/iphlpapi/tests/iphlpapi.c
index d5690c11eee..6965ae84570 100644
--- a/dlls/iphlpapi/tests/iphlpapi.c
+++ b/dlls/iphlpapi/tests/iphlpapi.c
@@ -1120,10 +1120,13 @@ static void testGetAdaptersInfo(void)
            apiReturn);
         ptr = buf;
         while (ptr) {
-            ok(ptr->IpAddressList.IpAddress.String[0], "A valid IP must be present\n");
+            ok(ptr->IpAddressList.IpAddress.String[0], "A valid IP address must be present\n");
             ok(ptr->IpAddressList.IpMask.String[0], "A valid mask must be present\n");
-            trace("Adapter '%s', IP %s, Mask %s\n", ptr->AdapterName,
-                  ptr->IpAddressList.IpAddress.String, ptr->IpAddressList.IpMask.String);
+            ok(ptr->GatewayList.IpAddress.String[0], "A valid IP address must be present\n");
+            ok(ptr->GatewayList.IpMask.String[0], "A valid mask must be present\n");
+            trace("adapter '%s', address %s/%s gateway %s/%s\n", ptr->AdapterName,
+                  ptr->IpAddressList.IpAddress.String, ptr->IpAddressList.IpMask.String,
+                  ptr->GatewayList.IpAddress.String, ptr->GatewayList.IpMask.String);
             ptr = ptr->Next;
         }
         HeapFree(GetProcessHeap(), 0, buf);
From d888f3ba3672a3e41af5d60c6494023cc38a0a02 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 3 Jul 2020 17:30:09 +0300
Subject: [PATCH] ws2_32: Consider socket with zero ifindex unbound.

Real interface index can't be zero.
getsockopt(..., IP_UNICAST_IF, ...) may return success and zero
interface index if IP_UNICAST_IF was never set.

Avoids error output which doesn't inidcate a real error condition
for such case.

Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/socket.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 402ee86d962..69fbb37af22 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -3788,7 +3788,7 @@ static void interface_bind_check(int fd, struct sockaddr_in *addr)
     ret = getsockopt(fd, IPPROTO_IP, IP_UNICAST_IF, &ifindex, &len);
     if (!ret) ifindex = ntohl(ifindex);
 #endif
-    if (!ret)
+    if (!ret && ifindex)
     {
         EnterCriticalSection(&cs_if_addr_cache);
         if (ifindex < if_addr_cache_size)
From da6386df8b759672e051304711bb6a5dc6ce9bd2 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Tue, 14 Jul 2020 09:03:47 +1000
Subject: [PATCH] ws2_32: Trace SIO_IDEAL_SEND_BACKLOG_* calls.

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/socket.c | 4 ++--
 include/ws2ipdef.h   | 8 ++++++++
 2 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 69fbb37af22..d7eddde44d8 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -4554,8 +4554,8 @@ static const char *debugstr_wsaioctl(DWORD code)
         IOCTL_NAME(WS_SIO_GET_INTERFACE_LIST);
         /* IOCTL_NAME(WS_SIO_GET_INTERFACE_LIST_EX); */
         IOCTL_NAME(WS_SIO_GET_QOS);
-        /* IOCTL_NAME(WS_SIO_IDEAL_SEND_BACKLOG_CHANGE);
-        IOCTL_NAME(WS_SIO_IDEAL_SEND_BACKLOG_QUERY); */
+        IOCTL_NAME(WS_SIO_IDEAL_SEND_BACKLOG_CHANGE);
+        IOCTL_NAME(WS_SIO_IDEAL_SEND_BACKLOG_QUERY);
         IOCTL_NAME(WS_SIO_KEEPALIVE_VALS);
         IOCTL_NAME(WS_SIO_MULTIPOINT_LOOPBACK);
         IOCTL_NAME(WS_SIO_MULTICAST_SCOPE);
diff --git a/include/ws2ipdef.h b/include/ws2ipdef.h
index 4cae361e5fe..fc465804962 100644
--- a/include/ws2ipdef.h
+++ b/include/ws2ipdef.h
@@ -282,6 +282,14 @@ typedef struct WS(in_pktinfo) {
 
 #define SS_PORT(ssp) (((PSOCKADDR_IN)(ssp))->sin_port)
 
+#ifndef USE_WS_PREFIX
+#define SIO_IDEAL_SEND_BACKLOG_CHANGE _IO ('t', 122)
+#define SIO_IDEAL_SEND_BACKLOG_QUERY  _IOR('t', 123, ULONG)
+#else
+#define WS_SIO_IDEAL_SEND_BACKLOG_CHANGE WS__IO ('t', 122)
+#define WS_SIO_IDEAL_SEND_BACKLOG_QUERY  WS__IOR('t', 123, ULONG)
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
From a16f91ae366b9f3f8e371598e13f4ef242f50af3 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Wed, 15 Jul 2020 01:19:04 -0600
Subject: [PATCH] ws2_32: Avoid depending on system getprotoby(name|number)
 functions.

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 configure                    |   2 -
 configure.ac                 |   2 -
 dlls/ws2_32/socket.c         |  79 +++++----------------------
 dlls/ws2_32/tests/protocol.c | 100 +++++++++++++++++++++++++++++++++++
 include/config.h.in          |   6 ---
 5 files changed, 114 insertions(+), 75 deletions(-)

diff --git a/configure b/configure
index 24d0a1d8b47..35f8b63ae06 100755
--- a/configure
+++ b/configure
@@ -18332,8 +18332,6 @@ for ac_func in \
 	getaddrinfo \
 	getnameinfo \
 	getnetbyname \
-	getprotobyname \
-	getprotobynumber \
 	getservbyport \
 
 do :
diff --git a/configure.ac b/configure.ac
index d914e3eca88..928f8ebd1b1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2245,8 +2245,6 @@ AC_CHECK_FUNCS(\
 	getaddrinfo \
 	getnameinfo \
 	getnetbyname \
-	getprotobyname \
-	getprotobynumber \
 	getservbyport \
 )
 
diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index d7eddde44d8..12126372d57 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -6509,56 +6509,23 @@ static const struct { int prot; const char *names[3]; } protocols[] =
 {
     {   0, { "ip", "IP" }},
     {   1, { "icmp", "ICMP" }},
-    {   2, { "igmp", "IGMP" }},
     {   3, { "ggp", "GGP" }},
     {   6, { "tcp", "TCP" }},
     {   8, { "egp", "EGP" }},
-    {   9, { "igp", "IGP" }},
     {  12, { "pup", "PUP" }},
     {  17, { "udp", "UDP" }},
     {  20, { "hmp", "HMP" }},
     {  22, { "xns-idp", "XNS-IDP" }},
     {  27, { "rdp", "RDP" }},
-    {  29, { "iso-tp4", "ISO-TP4" }},
-    {  33, { "dccp", "DCCP" }},
-    {  36, { "xtp", "XTP" }},
-    {  37, { "ddp", "DDP" }},
-    {  38, { "idpr-cmtp", "IDPR-CMTP" }},
     {  41, { "ipv6", "IPv6" }},
     {  43, { "ipv6-route", "IPv6-Route" }},
     {  44, { "ipv6-frag", "IPv6-Frag" }},
-    {  45, { "idrp", "IDRP" }},
-    {  46, { "rsvp", "RSVP" }},
-    {  47, { "gre", "GRE" }},
     {  50, { "esp", "ESP" }},
     {  51, { "ah", "AH" }},
-    {  57, { "skip", "SKIP" }},
     {  58, { "ipv6-icmp", "IPv6-ICMP" }},
     {  59, { "ipv6-nonxt", "IPv6-NoNxt" }},
     {  60, { "ipv6-opts", "IPv6-Opts" }},
     {  66, { "rvd", "RVD" }},
-    {  73, { "rspf", "RSPF" }},
-    {  81, { "vmtp", "VMTP" }},
-    {  88, { "eigrp", "EIGRP" }},
-    {  89, { "ospf", "OSPFIGP" }},
-    {  93, { "ax.25", "AX.25" }},
-    {  94, { "ipip", "IPIP" }},
-    {  97, { "etherip", "ETHERIP" }},
-    {  98, { "encap", "ENCAP" }},
-    { 103, { "pim", "PIM" }},
-    { 108, { "ipcomp", "IPCOMP" }},
-    { 112, { "vrrp", "VRRP" }},
-    { 115, { "l2tp", "L2TP" }},
-    { 124, { "isis", "ISIS" }},
-    { 132, { "sctp", "SCTP" }},
-    { 133, { "fc", "FC" }},
-    { 135, { "mobility-header", "Mobility-Header" }},
-    { 136, { "udplite", "UDPLite" }},
-    { 137, { "mpls-in-ip", "MPLS-in-IP" }},
-    { 139, { "hip", "HIP" }},
-    { 140, { "shim6", "Shim6" }},
-    { 141, { "wesp", "WESP" }},
-    { 142, { "rohc", "ROHC" }},
 };
 
 /***********************************************************************
@@ -6567,23 +6534,14 @@ static const struct { int prot; const char *names[3]; } protocols[] =
 struct WS_protoent* WINAPI WS_getprotobyname(const char* name)
 {
     struct WS_protoent* retval = NULL;
-#ifdef HAVE_GETPROTOBYNAME
-    struct protoent*     proto;
-    EnterCriticalSection( &csWSgetXXXbyYYY );
-    if( (proto = getprotobyname(name)) != NULL )
-        retval = WS_create_pe( proto->p_name, proto->p_aliases, proto->p_proto );
-    LeaveCriticalSection( &csWSgetXXXbyYYY );
-#endif
-    if (!retval)
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(protocols); i++)
     {
-        unsigned int i;
-        for (i = 0; i < ARRAY_SIZE(protocols); i++)
-        {
-            if (_strnicmp( protocols[i].names[0], name, -1 )) continue;
-            retval = WS_create_pe( protocols[i].names[0], (char **)protocols[i].names + 1,
-                                   protocols[i].prot );
-            break;
-        }
+        if (_strnicmp( protocols[i].names[0], name, -1 )) continue;
+        retval = WS_create_pe( protocols[i].names[0], (char **)protocols[i].names + 1,
+                               protocols[i].prot );
+        break;
     }
     if (!retval)
     {
@@ -6601,23 +6559,14 @@ struct WS_protoent* WINAPI WS_getprotobyname(const char* name)
 struct WS_protoent* WINAPI WS_getprotobynumber(int number)
 {
     struct WS_protoent* retval = NULL;
-#ifdef HAVE_GETPROTOBYNUMBER
-    struct protoent*     proto;
-    EnterCriticalSection( &csWSgetXXXbyYYY );
-    if( (proto = getprotobynumber(number)) != NULL )
-        retval = WS_create_pe( proto->p_name, proto->p_aliases, proto->p_proto );
-    LeaveCriticalSection( &csWSgetXXXbyYYY );
-#endif
-    if (!retval)
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(protocols); i++)
     {
-        unsigned int i;
-        for (i = 0; i < ARRAY_SIZE(protocols); i++)
-        {
-            if (protocols[i].prot != number) continue;
-            retval = WS_create_pe( protocols[i].names[0], (char **)protocols[i].names + 1,
-                                   protocols[i].prot );
-            break;
-        }
+        if (protocols[i].prot != number) continue;
+        retval = WS_create_pe( protocols[i].names[0], (char **)protocols[i].names + 1,
+                               protocols[i].prot );
+        break;
     }
     if (!retval)
     {
diff --git a/dlls/ws2_32/tests/protocol.c b/dlls/ws2_32/tests/protocol.c
index 99bd1373a94..de5fe36d456 100644
--- a/dlls/ws2_32/tests/protocol.c
+++ b/dlls/ws2_32/tests/protocol.c
@@ -192,6 +192,104 @@ static void test_WSAEnumProtocolsW(void)
     }
 }
 
+struct protocol
+{
+    int prot;
+    const char *names[2];
+    BOOL missing_from_xp;
+};
+
+static const struct protocol protocols[] =
+{
+    {   0, { "ip", "IP" }},
+    {   1, { "icmp", "ICMP" }},
+    {   3, { "ggp", "GGP" }},
+    {   6, { "tcp", "TCP" }},
+    {   8, { "egp", "EGP" }},
+    {  12, { "pup", "PUP" }},
+    {  17, { "udp", "UDP" }},
+    {  20, { "hmp", "HMP" }},
+    {  22, { "xns-idp", "XNS-IDP" }},
+    {  27, { "rdp", "RDP" }},
+    {  41, { "ipv6", "IPv6" }, TRUE},
+    {  43, { "ipv6-route", "IPv6-Route" }, TRUE},
+    {  44, { "ipv6-frag", "IPv6-Frag" }, TRUE},
+    {  50, { "esp", "ESP" }},
+    {  51, { "ah", "AH" }},
+    {  58, { "ipv6-icmp", "IPv6-ICMP" }, TRUE},
+    {  59, { "ipv6-nonxt", "IPv6-NoNxt" }, TRUE},
+    {  60, { "ipv6-opts", "IPv6-Opts" }, TRUE},
+    {  66, { "rvd", "RVD" }},
+};
+
+static const struct protocol *find_protocol(int number)
+{
+    int i;
+    for (i = 0; i < ARRAY_SIZE(protocols); i++)
+    {
+        if (protocols[i].prot == number)
+            return &protocols[i];
+    }
+    return NULL;
+}
+
+static void test_getprotobyname(void)
+{
+    struct protoent *ent;
+    char all_caps_name[16];
+    int i, j;
+
+    for (i = 0; i < ARRAY_SIZE(protocols); i++)
+    {
+        for (j = 0; j < ARRAY_SIZE(protocols[0].names); j++)
+        {
+            ent = getprotobyname(protocols[i].names[j]);
+            ok((ent && ent->p_proto == protocols[i].prot) || broken(!ent && protocols[i].missing_from_xp),
+               "Expected %s to be protocol number %d, got %d\n",
+               wine_dbgstr_a(protocols[i].names[j]), protocols[i].prot, ent ? ent->p_proto : -1);
+        }
+
+        for (j = 0; protocols[i].names[0][j]; j++)
+            all_caps_name[j] = toupper(protocols[i].names[0][j]);
+        all_caps_name[j] = 0;
+        ent = getprotobyname(all_caps_name);
+        ok((ent && ent->p_proto == protocols[i].prot) || broken(!ent && protocols[i].missing_from_xp),
+           "Expected %s to be protocol number %d, got %d\n",
+           wine_dbgstr_a(all_caps_name), protocols[i].prot, ent ? ent->p_proto : -1);
+    }
+}
+
+static void test_getprotobynumber(void)
+{
+    struct protoent *ent;
+    const struct protocol *ref;
+    int i;
+
+    for (i = -1; i <= 256; i++)
+    {
+        ent = getprotobynumber(i);
+        ref = find_protocol(i);
+
+        if (!ref)
+        {
+            ok(!ent, "Expected protocol number %d to be undefined, got %s\n",
+               i, wine_dbgstr_a(ent ? ent->p_name : NULL));
+            continue;
+        }
+
+        ok((ent && ent->p_name && strcmp(ent->p_name, ref->names[0]) == 0) ||
+           broken(!ent && ref->missing_from_xp),
+           "Expected protocol number %d to be %s, got %s\n",
+           i, ref->names[0], wine_dbgstr_a(ent ? ent->p_name : NULL));
+
+        ok((ent && ent->p_aliases && ent->p_aliases[0] &&
+            strcmp(ent->p_aliases[0], ref->names[1]) == 0) ||
+           broken(!ent && ref->missing_from_xp),
+           "Expected protocol number %d alias 0 to be %s, got %s\n",
+           i, ref->names[0], wine_dbgstr_a(ent && ent->p_aliases ? ent->p_aliases[0] : NULL));
+    }
+}
+
 START_TEST( protocol )
 {
     WSADATA data;
@@ -201,4 +299,6 @@ START_TEST( protocol )
 
     test_WSAEnumProtocolsA();
     test_WSAEnumProtocolsW();
+    test_getprotobyname();
+    test_getprotobynumber();
 }
diff --git a/include/config.h.in b/include/config.h.in
index 720cbd4a5d9..3a3277e613d 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -245,12 +245,6 @@
 /* Define to 1 if you have the `getopt_long_only' function. */
 #undef HAVE_GETOPT_LONG_ONLY
 
-/* Define to 1 if you have the `getprotobyname' function. */
-#undef HAVE_GETPROTOBYNAME
-
-/* Define to 1 if you have the `getprotobynumber' function. */
-#undef HAVE_GETPROTOBYNUMBER
-
 /* Define to 1 if you have the `getservbyport' function. */
 #undef HAVE_GETSERVBYPORT
 
From 046475d88eed9b23b41189fe92c30d1caaef1184 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Mon, 27 Jul 2020 00:25:46 -0600
Subject: [PATCH] ws2_32/tests: Allow ESP and AH protocols to be missing on
 Windows.

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/tests/protocol.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/ws2_32/tests/protocol.c b/dlls/ws2_32/tests/protocol.c
index de5fe36d456..d6e454a5fbd 100644
--- a/dlls/ws2_32/tests/protocol.c
+++ b/dlls/ws2_32/tests/protocol.c
@@ -214,8 +214,8 @@ static const struct protocol protocols[] =
     {  41, { "ipv6", "IPv6" }, TRUE},
     {  43, { "ipv6-route", "IPv6-Route" }, TRUE},
     {  44, { "ipv6-frag", "IPv6-Frag" }, TRUE},
-    {  50, { "esp", "ESP" }},
-    {  51, { "ah", "AH" }},
+    {  50, { "esp", "ESP" }, TRUE},
+    {  51, { "ah", "AH" }, TRUE},
     {  58, { "ipv6-icmp", "IPv6-ICMP" }, TRUE},
     {  59, { "ipv6-nonxt", "IPv6-NoNxt" }, TRUE},
     {  60, { "ipv6-opts", "IPv6-Opts" }, TRUE},
From 587732acb7834a52a2af5bb45e59899ab8ec3f5d Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 27 Jul 2020 12:51:46 +1000
Subject: [PATCH] ws2_32: Correct returned error code for an invalid socket.

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/socket.c     | 32 +++++++-------------------------
 dlls/ws2_32/tests/sock.c |  7 ++-----
 2 files changed, 9 insertions(+), 30 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 12126372d57..eb21e4b4b35 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -1119,8 +1119,8 @@ static DWORD NtStatusToWSAError( DWORD status )
     {
     case STATUS_SUCCESS:                    return 0;
     case STATUS_PENDING:                    return WSA_IO_PENDING;
+    case STATUS_INVALID_HANDLE:
     case STATUS_OBJECT_TYPE_MISMATCH:       return WSAENOTSOCK;
-    case STATUS_INVALID_HANDLE:             return WSAEBADF;
     case STATUS_INVALID_PARAMETER:          return WSAEINVAL;
     case STATUS_PIPE_DISCONNECTED:          return WSAESHUTDOWN;
     case STATUS_NETWORK_BUSY:               return WSAEALREADY;
@@ -2889,19 +2889,11 @@ static BOOL WINAPI WS2_AcceptEx(SOCKET listener, SOCKET acceptor, PVOID dest, DW
     }
 
     fd = get_sock_fd( listener, FILE_READ_DATA, NULL );
-    if (fd == -1)
-    {
-        SetLastError(WSAENOTSOCK);
-        return FALSE;
-    }
+    if (fd == -1) return FALSE;
     release_sock_fd( listener, fd );
 
     fd = get_sock_fd( acceptor, FILE_READ_DATA, NULL );
-    if (fd == -1)
-    {
-        SetLastError(WSAENOTSOCK);
-        return FALSE;
-    }
+    if (fd == -1) return FALSE;
     release_sock_fd( acceptor, fd );
 
     wsa = (struct ws2_accept_async *)alloc_async_io( sizeof(*wsa), WS2_async_accept );
@@ -3147,11 +3139,8 @@ static BOOL WINAPI WS2_TransmitFile( SOCKET s, HANDLE h, DWORD file_bytes, DWORD
             buffers, flags );
 
     fd = get_sock_fd( s, FILE_WRITE_DATA, NULL );
-    if (fd == -1)
-    {
-        WSASetLastError( WSAENOTSOCK );
-        return FALSE;
-    }
+    if (fd == -1) return FALSE;
+
     if (getpeername( fd, &uaddr.addr, &uaddrlen ) != 0)
     {
         release_sock_fd( s, fd );
@@ -3497,8 +3486,6 @@ int WINAPI WS_closesocket(SOCKET s)
             if (CloseHandle(SOCKET2HANDLE(s)))
                 res = 0;
         }
-        else
-            SetLastError(WSAENOTSOCK);
     }
     else
         SetLastError(WSANOTINITIALISED);
@@ -3609,11 +3596,7 @@ static BOOL WINAPI WS2_ConnectEx(SOCKET s, const struct WS_sockaddr* name, int n
     }
 
     fd = get_sock_fd( s, FILE_READ_DATA, NULL );
-    if (fd == -1)
-    {
-        SetLastError( WSAENOTSOCK );
-        return FALSE;
-    }
+    if (fd == -1) return FALSE;
 
     TRACE("socket %04lx, ptr %p %s, length %d, sendptr %p, len %d, ov %p\n",
           s, name, debugstr_sockaddr(name), namelen, sendBuf, sendBufLen, ov);
@@ -5207,8 +5190,7 @@ int WINAPI WS_listen(SOCKET s, int backlog)
             SetLastError(wsaErrno());
         release_sock_fd( s, fd );
     }
-    else
-        SetLastError(WSAENOTSOCK);
+
     return ret;
 }
 
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index d9ceca98cc6..b7a3fc44539 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -1565,7 +1565,6 @@ todo_wine
     size = sizeof(i);
     i = 1234;
     err = getsockopt(s, SOL_SOCKET, SO_ERROR, (char *) &i, &size);
-todo_wine
     ok( (err == SOCKET_ERROR) && (WSAGetLastError() == WSAENOTSOCK),
         "got %d with %d (expected SOCKET_ERROR with WSAENOTSOCK)\n",
         err, WSAGetLastError());
@@ -3850,8 +3849,7 @@ static void test_select(void)
     SetLastError(0xdeadbeef);
     ret = select(0, &readfds, NULL, &exceptfds, &select_timeout);
     ok(ret == SOCKET_ERROR, "expected -1, got %d\n", ret);
-todo_wine
-    ok(GetLastError() == WSAENOTSOCK, "expected 10038, got %d\n", GetLastError());
+    ok(GetLastError() == WSAENOTSOCK, "got %d\n", GetLastError());
     /* descriptor sets are unchanged */
     ok(readfds.fd_count == 2, "expected 2, got %d\n", readfds.fd_count);
     ok(exceptfds.fd_count == 2, "expected 2, got %d\n", exceptfds.fd_count);
@@ -3878,8 +3876,7 @@ todo_wine
     ret = select(0, NULL, NULL, &exceptfds, &select_timeout);
 todo_wine
     ok(ret == SOCKET_ERROR, "expected -1, got %d\n", ret);
-todo_wine
-    ok(GetLastError() == WSAENOTSOCK, "expected 10038, got %d\n", GetLastError());
+    ok(GetLastError() == WSAENOTSOCK, "got %d\n", GetLastError());
     WaitForSingleObject (thread_handle, 1000);
     closesocket(fdRead);
 

From c06e00ee6a15fd77faf66b28edac5e84ad30b550 Mon Sep 17 00:00:00 2001
From: Jactry Zeng <jzeng@codeweavers.com>
Date: Wed, 29 Jul 2020 13:39:28 +0200
Subject: [PATCH] wininet: Handle empty expires for cookie setting.

Signed-off-by: Jactry Zeng <jzeng@codeweavers.com>
Signed-off-by: Jacek Caban <jacek@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wininet/cookie.c         |  2 +-
 dlls/wininet/tests/internet.c | 18 ++++++++++++++----
 2 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/dlls/wininet/cookie.c b/dlls/wininet/cookie.c
index 1786b3d2819..66c012a0db0 100644
--- a/dlls/wininet/cookie.c
+++ b/dlls/wininet/cookie.c
@@ -977,7 +977,7 @@ DWORD set_cookie(substr_t domain, substr_t path, substr_t name, substr_t data, D
 
             substr_skip(&data, len);
 
-            if(end_ptr - data.str < ARRAY_SIZE(buf)-1) {
+            if(end_ptr > data.str && (end_ptr - data.str < ARRAY_SIZE(buf) - 1)) {
                 memcpy(buf, data.str, data.len*sizeof(WCHAR));
                 buf[data.len] = 0;
 
diff --git a/dlls/wininet/tests/internet.c b/dlls/wininet/tests/internet.c
index e69b45a7e6f..ef1adefd1a3 100644
--- a/dlls/wininet/tests/internet.c
+++ b/dlls/wininet/tests/internet.c
@@ -510,7 +510,7 @@ static void test_complicated_cookie(void)
   len = 1024;
   ret = InternetGetCookieA("http://testing.example.com/bar/foo", NULL, buffer, &len);
   ok(ret == TRUE,"InternetGetCookie failed\n");
-  ok(len == 24, "len = %u\n", 24);
+  ok(len == 24, "len = %u\n", len);
   ok(strstr(buffer,"A=B")!=NULL,"A=B missing\n");
   ok(strstr(buffer,"C=D")!=NULL,"C=D missing\n");
   ok(strstr(buffer,"E=F")!=NULL,"E=F missing\n");
@@ -524,16 +524,26 @@ static void test_complicated_cookie(void)
   len = 1024;
   ret = InternetGetCookieA("http://testing.example.com/bar/foo", "A", buffer, &len);
   ok(ret == TRUE,"InternetGetCookie failed\n");
-  ok(len == 24, "len = %u\n", 24);
+  ok(len == 24, "len = %u\n", len);
 
   /* test persistent cookies */
   ret = InternetSetCookieA("http://testing.example.com", NULL, "A=B; expires=Fri, 01-Jan-2038 00:00:00 GMT");
   ok(ret, "InternetSetCookie failed with error %d\n", GetLastError());
 
+  /* test invalid expires parameter */
+  ret = InternetSetCookieA("http://testing.example.com", NULL, "Q=R; expires=");
+  ok(ret, "InternetSetCookie failed %#x.\n", GetLastError());
+  len = 1024;
+  memset(buffer, 0xac, sizeof(buffer));
+  ret = InternetGetCookieA("http://testing.example.com/", NULL, buffer, &len);
+  ok(ret, "InternetGetCookie failed %#x.\n", GetLastError());
+  ok(len == 29, "got len %u.\n", len);
+  ok(!!strstr(buffer, "Q=R"), "cookie is not present.\n");
+
   len = sizeof(buffer);
   ret = InternetGetCookieA("http://testing.example.com/foobar", NULL, buffer, &len);
-  ok(ret, "got error %u\n", GetLastError());
-  ok(len == 24, "got len %u\n", len);
+  ok(ret, "got error %#x\n", GetLastError());
+  ok(len == 29, "got len %u\n", len);
   ok(!!strstr(buffer, "A=B"), "cookie is not present\n");
 
   /* remove persistent cookie */
From a41cb33afaee0adc6fdf3b8c69b9fb545dc15a96 Mon Sep 17 00:00:00 2001
From: Daniel Lehman <dlehman25@gmail.com>
Date: Sun, 2 Aug 2020 16:23:39 -0700
Subject: [PATCH] wininet: Move INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT
 handling to helper.

Signed-off-by: Daniel Lehman <dlehman25@gmail.com>
Signed-off-by: Jacek Caban <jacek@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/wininet/http.c | 62 ++++++++++++++++++++++++---------------------
 1 file changed, 33 insertions(+), 29 deletions(-)

diff --git a/dlls/wininet/http.c b/dlls/wininet/http.c
index 56c995805b2..220493718c3 100644
--- a/dlls/wininet/http.c
+++ b/dlls/wininet/http.c
@@ -2083,6 +2083,38 @@ static DWORD str_to_buffer(const WCHAR *str, void *buffer, DWORD *size, BOOL uni
     }
 }
 
+static DWORD get_security_cert_struct(http_request_t *req, INTERNET_CERTIFICATE_INFOA *info)
+{
+    PCCERT_CONTEXT context;
+    DWORD len;
+
+    context = (PCCERT_CONTEXT)NETCON_GetCert(req->netconn);
+    if(!context)
+        return ERROR_NOT_SUPPORTED;
+
+    memset(info, 0, sizeof(*info));
+    info->ftExpiry = context->pCertInfo->NotAfter;
+    info->ftStart = context->pCertInfo->NotBefore;
+    len = CertNameToStrA(context->dwCertEncodingType,
+             &context->pCertInfo->Subject, CERT_SIMPLE_NAME_STR|CERT_NAME_STR_CRLF_FLAG, NULL, 0);
+    info->lpszSubjectInfo = LocalAlloc(0, len);
+    if(info->lpszSubjectInfo)
+        CertNameToStrA(context->dwCertEncodingType,
+                 &context->pCertInfo->Subject, CERT_SIMPLE_NAME_STR|CERT_NAME_STR_CRLF_FLAG,
+                 info->lpszSubjectInfo, len);
+    len = CertNameToStrA(context->dwCertEncodingType,
+             &context->pCertInfo->Issuer, CERT_SIMPLE_NAME_STR|CERT_NAME_STR_CRLF_FLAG, NULL, 0);
+    info->lpszIssuerInfo = LocalAlloc(0, len);
+    if(info->lpszIssuerInfo)
+        CertNameToStrA(context->dwCertEncodingType,
+                 &context->pCertInfo->Issuer, CERT_SIMPLE_NAME_STR|CERT_NAME_STR_CRLF_FLAG,
+                 info->lpszIssuerInfo, len);
+    info->dwKeySize = NETCON_GetCipherStrength(req->netconn);
+
+    CertFreeCertificateContext(context);
+    return ERROR_SUCCESS;
+}
+
 static DWORD HTTPREQ_QueryOption(object_header_t *hdr, DWORD option, void *buffer, DWORD *size, BOOL unicode)
 {
     http_request_t *req = (http_request_t*)hdr;
@@ -2235,8 +2267,6 @@ static DWORD HTTPREQ_QueryOption(object_header_t *hdr, DWORD option, void *buffe
     }
 
     case INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT: {
-        PCCERT_CONTEXT context;
-
         if(!req->netconn)
             return ERROR_INTERNET_INVALID_OPERATION;
 
@@ -2245,33 +2275,7 @@ static DWORD HTTPREQ_QueryOption(object_header_t *hdr, DWORD option, void *buffe
             return ERROR_INSUFFICIENT_BUFFER;
         }
 
-        context = (PCCERT_CONTEXT)NETCON_GetCert(req->netconn);
-        if(context) {
-            INTERNET_CERTIFICATE_INFOA *info = (INTERNET_CERTIFICATE_INFOA*)buffer;
-            DWORD len;
-
-            memset(info, 0, sizeof(*info));
-            info->ftExpiry = context->pCertInfo->NotAfter;
-            info->ftStart = context->pCertInfo->NotBefore;
-            len = CertNameToStrA(context->dwCertEncodingType,
-                     &context->pCertInfo->Subject, CERT_SIMPLE_NAME_STR|CERT_NAME_STR_CRLF_FLAG, NULL, 0);
-            info->lpszSubjectInfo = LocalAlloc(0, len);
-            if(info->lpszSubjectInfo)
-                CertNameToStrA(context->dwCertEncodingType,
-                         &context->pCertInfo->Subject, CERT_SIMPLE_NAME_STR|CERT_NAME_STR_CRLF_FLAG,
-                         info->lpszSubjectInfo, len);
-            len = CertNameToStrA(context->dwCertEncodingType,
-                     &context->pCertInfo->Issuer, CERT_SIMPLE_NAME_STR|CERT_NAME_STR_CRLF_FLAG, NULL, 0);
-            info->lpszIssuerInfo = LocalAlloc(0, len);
-            if(info->lpszIssuerInfo)
-                CertNameToStrA(context->dwCertEncodingType,
-                         &context->pCertInfo->Issuer, CERT_SIMPLE_NAME_STR|CERT_NAME_STR_CRLF_FLAG,
-                         info->lpszIssuerInfo, len);
-            info->dwKeySize = NETCON_GetCipherStrength(req->netconn);
-            CertFreeCertificateContext(context);
-            return ERROR_SUCCESS;
-        }
-        return ERROR_NOT_SUPPORTED;
+        return get_security_cert_struct(req, (INTERNET_CERTIFICATE_INFOA*)buffer);
     }
     case INTERNET_OPTION_CONNECT_TIMEOUT:
         if (*size < sizeof(DWORD))
From a6d9f46b25a481648a2a06ed8d1594fc59a4e313 Mon Sep 17 00:00:00 2001
From: Hans Leidekker <hans@codeweavers.com>
Date: Tue, 11 Aug 2020 14:11:05 +0200
Subject: [PATCH] ws2_32: Avoid a crash in WS_getaddrinfo when the specified
 service doesn't exist.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49656
Signed-off-by: Hans Leidekker <hans@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/socket.c     | 2 +-
 dlls/ws2_32/tests/sock.c | 4 ++++
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index eb21e4b4b35..4d2afa946b7 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -6787,7 +6787,7 @@ int WINAPI WS_getaddrinfo(LPCSTR nodename, LPCSTR servname, const struct WS_addr
     result = getaddrinfo(node, servname, punixhints, &unixaires);
 
     if (result && (!hints || !(hints->ai_flags & WS_AI_NUMERICHOST))
-            && (!strcmp(fqdn, node) || (!strncmp(fqdn, node, hostname_len) && !node[hostname_len])))
+            && node && (!strcmp(fqdn, node) || (!strncmp(fqdn, node, hostname_len) && !node[hostname_len])))
     {
         /* If it didn't work it means the host name IP is not in /etc/hosts, try again
         * by sending a NULL host and avoid sending a NULL servname too because that
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index b7a3fc44539..b523c326d60 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -7778,6 +7778,10 @@ static void test_getaddrinfo(void)
                 ok(0, "test %d: getaddrinfo failed with %d (err %d)\n", i, ret, err);
         }
     }
+
+    memset(&hint, 0, sizeof(hint));
+    ret = pgetaddrinfo(NULL, "nonexistentservice", &hint, &result);
+    ok(ret == WSATYPE_NOT_FOUND, "got %d\n", ret);
 }
 
 static void test_ConnectEx(void)
From 652f1f9642b35a2a1d1c5b67e4326af7d45363b4 Mon Sep 17 00:00:00 2001
From: Aaro Altonen <a.altonen@hotmail.com>
Date: Tue, 25 Aug 2020 20:27:28 +0200
Subject: [PATCH] ws2_32: Improve WSCGetProviderPath() stub.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45801
Signed-off-by: Aaro Altonen <a.altonen@hotmail.com>
Signed-off-by: Gijs Vermeulen <gijsvrm@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/socket.c     | 17 +++++++++--
 dlls/ws2_32/tests/sock.c | 62 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 76 insertions(+), 3 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 4d2afa946b7..b7a570043cd 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -8940,10 +8940,21 @@ INT WINAPI WSCGetProviderPath( LPGUID provider, LPWSTR path, LPINT len, LPINT er
 {
     FIXME( "(%s %p %p %p) Stub!\n", debugstr_guid(provider), path, len, errcode );
 
-    if (!errcode || !provider || !len) return WSAEFAULT;
+    if (!provider || !len)
+    {
+        if (errcode)
+            *errcode = WSAEFAULT;
+        return SOCKET_ERROR;
+    }
 
-    *errcode = WSAEINVAL;
-    return SOCKET_ERROR;
+    if (*len <= 0)
+    {
+        if (errcode)
+            *errcode = WSAEINVAL;
+        return SOCKET_ERROR;
+    }
+
+    return 0;
 }
 
 /***********************************************************************
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index b523c326d60..c7f88d6f3b1 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -86,6 +86,7 @@ static int   (WINAPI *pWSAEnumNameSpaceProvidersA)(LPDWORD,LPWSANAMESPACE_INFOA)
 static int   (WINAPI *pWSAEnumNameSpaceProvidersW)(LPDWORD,LPWSANAMESPACE_INFOW);
 static int   (WINAPI *pWSAPoll)(WSAPOLLFD *,ULONG,INT);
 static int   (WINAPI *pWSCGetProviderInfo)(LPGUID,WSC_PROVIDER_INFO_TYPE,PBYTE,size_t*,DWORD,LPINT);
+static int   (WINAPI *pWSCGetProviderPath)(LPGUID, LPWSTR, LPINT, LPINT);
 
 /* Function pointers from iphlpapi */
 static DWORD (WINAPI *pGetAdaptersInfo)(PIP_ADAPTER_INFO,PULONG);
@@ -1303,6 +1304,7 @@ static void Init (void)
     pWSAEnumNameSpaceProvidersW = (void *)GetProcAddress(hws2_32, "WSAEnumNameSpaceProvidersW");
     pWSAPoll = (void *)GetProcAddress(hws2_32, "WSAPoll");
     pWSCGetProviderInfo = (void *)GetProcAddress(hws2_32, "WSCGetProviderInfo");
+    pWSCGetProviderPath = (void *)GetProcAddress(hws2_32, "WSCGetProviderPath");
 
     hiphlpapi = LoadLibraryA("iphlpapi.dll");
     if (hiphlpapi)
@@ -11351,6 +11353,65 @@ static void test_WSCGetProviderInfo(void)
     ok(errcode == WSANO_RECOVERY, "got %d, expected WSANO_RECOVERY\n", errcode);
 }
 
+static void test_WSCGetProviderPath(void)
+{
+    GUID provider = {};
+    WCHAR buffer[256];
+    INT ret, err, len;
+
+    if (!pWSCGetProviderPath)
+    {
+        skip("WSCGetProviderPath is not available.\n");
+        return;
+    }
+
+    ret = pWSCGetProviderPath(NULL, NULL, NULL, NULL);
+    ok(ret == SOCKET_ERROR, "Got unexpected ret %d.\n", ret);
+
+    ret = pWSCGetProviderPath(&provider, NULL, NULL, NULL);
+    ok(ret == SOCKET_ERROR, "Got unexpected ret %d.\n", ret);
+
+    ret = pWSCGetProviderPath(NULL, buffer, NULL, NULL);
+    ok(ret == SOCKET_ERROR, "Got unexpected ret %d.\n", ret);
+
+    len = -1;
+    ret = pWSCGetProviderPath(NULL, NULL, &len, NULL);
+    ok(ret == SOCKET_ERROR, "Got unexpected ret %d.\n", ret);
+    ok(len == -1, "Got unexpected len %d.\n", len);
+
+    err = 0;
+    ret = pWSCGetProviderPath(NULL, NULL, NULL, &err);
+    ok(ret == SOCKET_ERROR, "Got unexpected ret %d.\n", ret);
+    ok(err == WSAEFAULT, "Got unexpected error %d.\n", err);
+
+    err = 0;
+    ret = pWSCGetProviderPath(&provider, NULL, NULL, &err);
+    ok(ret == SOCKET_ERROR, "Got unexpected ret %d.\n", ret);
+    ok(err == WSAEFAULT, "Got unexpected error %d.\n", err);
+
+    err = 0;
+    len = -1;
+    ret = pWSCGetProviderPath(&provider, NULL, &len, &err);
+    ok(ret == SOCKET_ERROR, "Got unexpected ret %d.\n", ret);
+    ok(err == WSAEINVAL, "Got unexpected error %d.\n", err);
+    ok(len == -1, "Got unexpected len %d.\n", len);
+
+    err = 0;
+    len = 256;
+    ret = pWSCGetProviderPath(&provider, NULL, &len, &err);
+    todo_wine ok(ret == SOCKET_ERROR, "Got unexpected ret %d.\n", ret);
+    todo_wine ok(err == WSAEINVAL, "Got unexpected error %d.\n", err);
+    ok(len == 256, "Got unexpected len %d.\n", len);
+
+    /* Valid pointers and length but invalid GUID */
+    err = 0;
+    len = 256;
+    ret = pWSCGetProviderPath(&provider, buffer, &len, &err);
+    todo_wine ok(ret == SOCKET_ERROR, "Got unexpected ret %d.\n", ret);
+    todo_wine ok(err == WSAEINVAL, "Got unexpected error %d.\n", err);
+    ok(len == 256, "Got unexpected len %d.\n", len);
+}
+
 START_TEST( sock )
 {
     int i;
@@ -11432,6 +11493,7 @@ START_TEST( sock )
     test_address_list_query();
 
     test_WSCGetProviderInfo();
+    test_WSCGetProviderPath();
 
     /* this is an io heavy test, do it at the end so the kernel doesn't start dropping packets */
     test_send();
From 23dbfaadbb93eea84601d763d303273ab9872f66 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 10 Sep 2020 16:17:14 -0500
Subject: [PATCH] ws2_32: Keep a list of open sockets.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/socket.c | 99 ++++++++++++++++++++++++++++++++++----------
 1 file changed, 77 insertions(+), 22 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index b7a570043cd..44214630296 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -267,26 +267,22 @@ static int WS2_recv_base( SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount,
                           LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
                           LPWSABUF lpControlBuffer );
 
-/* critical section to protect some non-reentrant net function */
-static CRITICAL_SECTION csWSgetXXXbyYYY;
-static CRITICAL_SECTION_DEBUG critsect_debug =
-{
-    0, 0, &csWSgetXXXbyYYY,
-    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
-      0, 0, { (DWORD_PTR)(__FILE__ ": csWSgetXXXbyYYY") }
-};
-static CRITICAL_SECTION csWSgetXXXbyYYY = { &critsect_debug, -1, 0, 0, 0, 0 };
+#define DECLARE_CRITICAL_SECTION(cs) \
+    static CRITICAL_SECTION cs; \
+    static CRITICAL_SECTION_DEBUG cs##_debug = \
+    { 0, 0, &cs, { &cs##_debug.ProcessLocksList, &cs##_debug.ProcessLocksList }, \
+      0, 0, { (DWORD_PTR)(__FILE__ ": " # cs) }}; \
+    static CRITICAL_SECTION cs = { &cs##_debug, -1, 0, 0, 0, 0 }
+
+DECLARE_CRITICAL_SECTION(csWSgetXXXbyYYY);
+DECLARE_CRITICAL_SECTION(cs_if_addr_cache);
+DECLARE_CRITICAL_SECTION(cs_socket_list);
 
 static in_addr_t *if_addr_cache;
 static unsigned int if_addr_cache_size;
-static CRITICAL_SECTION cs_if_addr_cache;
-static CRITICAL_SECTION_DEBUG cs_if_addr_cache_debug =
-{
-    0, 0, &cs_if_addr_cache,
-    { &cs_if_addr_cache_debug.ProcessLocksList, &cs_if_addr_cache_debug.ProcessLocksList },
-      0, 0, { (DWORD_PTR)(__FILE__ ": cs_if_addr_cache") }
-};
-static CRITICAL_SECTION cs_if_addr_cache = { &cs_if_addr_cache_debug, -1, 0, 0, 0, 0 };
+
+static SOCKET *socket_list;
+static unsigned int socket_list_size;
 
 union generic_unix_sockaddr
 {
@@ -481,6 +477,48 @@ static inline const char *debugstr_optval(const char *optval, int optlenval)
 #define SOCKET2HANDLE(s) ((HANDLE)(s))
 #define HANDLE2SOCKET(h) ((SOCKET)(h))
 
+static BOOL socket_list_add(SOCKET socket)
+{
+    unsigned int i, new_size;
+    SOCKET *new_array;
+
+    EnterCriticalSection(&cs_socket_list);
+    for (i = 0; i < socket_list_size; ++i)
+    {
+        if (!socket_list[i])
+        {
+            socket_list[i] = socket;
+            LeaveCriticalSection(&cs_socket_list);
+            return TRUE;
+        }
+    }
+    new_size = max(socket_list_size * 2, 8);
+    if (!(new_array = heap_realloc(socket_list, new_size * sizeof(*socket_list))))
+        return FALSE;
+    socket_list = new_array;
+    memset(socket_list + socket_list_size, 0, (new_size - socket_list_size) * sizeof(*socket_list));
+    socket_list[socket_list_size] = socket;
+    socket_list_size = new_size;
+    LeaveCriticalSection(&cs_socket_list);
+    return TRUE;
+}
+
+static void socket_list_remove(SOCKET socket)
+{
+    unsigned int i;
+
+    EnterCriticalSection(&cs_socket_list);
+    for (i = 0; i < socket_list_size; ++i)
+    {
+        if (socket_list[i] == socket)
+        {
+            socket_list[i] = 0;
+            break;
+        }
+    }
+    LeaveCriticalSection(&cs_socket_list);
+}
+
 /****************************************************************
  * Async IO declarations
  ****************************************************************/
@@ -2832,6 +2870,11 @@ SOCKET WINAPI WS_accept(SOCKET s, struct WS_sockaddr *addr, int *addrlen32)
         SERVER_END_REQ;
         if (!err)
         {
+            if (!socket_list_add(as))
+            {
+                CloseHandle(SOCKET2HANDLE(as));
+                return SOCKET_ERROR;
+            }
             if (addr && addrlen32 && WS_getpeername(as, addr, addrlen32))
             {
                 WS_closesocket(as);
@@ -3483,6 +3526,7 @@ int WINAPI WS_closesocket(SOCKET s)
         if (fd >= 0)
         {
             release_sock_fd(s, fd);
+            socket_list_remove(s);
             if (CloseHandle(SOCKET2HANDLE(s)))
                 res = 0;
         }
@@ -7558,10 +7602,16 @@ SOCKET WINAPI WSASocketW(int af, int type, int protocol,
     }
 
     /* hack for WSADuplicateSocket */
-    if (lpProtocolInfo && lpProtocolInfo->dwServiceFlags4 == 0xff00ff00) {
-      ret = lpProtocolInfo->dwServiceFlags3;
-      TRACE("\tgot duplicate %04lx\n", ret);
-      return ret;
+    if (lpProtocolInfo && lpProtocolInfo->dwServiceFlags4 == 0xff00ff00)
+    {
+        ret = lpProtocolInfo->dwServiceFlags3;
+        TRACE("\tgot duplicate %04lx\n", ret);
+        if (!socket_list_add(ret))
+        {
+            CloseHandle(SOCKET2HANDLE(ret));
+            return INVALID_SOCKET;
+        }
+        return ret;
     }
 
     if (lpProtocolInfo)
@@ -7685,7 +7735,12 @@ SOCKET WINAPI WSASocketW(int af, int type, int protocol,
             }
         }
 #endif
-       return ret;
+        if (!socket_list_add(ret))
+        {
+            CloseHandle(SOCKET2HANDLE(ret));
+            return INVALID_SOCKET;
+        }
+        return ret;
     }
 
     if (err == WSAEACCES) /* raw socket denied */
From 470b9d037988cf5e79b039370e2c6c55daf3459c Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 10 Sep 2020 16:17:15 -0500
Subject: [PATCH] ws2_32: Close all open sockets in WSACleanup().

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=18670
Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/socket.c     | 14 +++++++++++---
 dlls/ws2_32/tests/sock.c |  3 ---
 2 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 44214630296..246a0e2819b 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -1770,9 +1770,17 @@ int WINAPI WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData)
  */
 INT WINAPI WSACleanup(void)
 {
-    if (num_startup) {
-        num_startup--;
-        TRACE("pending cleanups: %d\n", num_startup);
+    TRACE("decreasing startup count from %d\n", num_startup);
+    if (num_startup)
+    {
+        if (!--num_startup)
+        {
+            unsigned int i;
+
+            for (i = 0; i < socket_list_size; ++i)
+                CloseHandle(SOCKET2HANDLE(socket_list[i]));
+            memset(socket_list, 0, socket_list_size * sizeof(*socket_list));
+        }
         return 0;
     }
     SetLastError(WSANOTINITIALISED);
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index c7f88d6f3b1..7835246397d 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -1221,7 +1221,6 @@ static void test_WithWSAStartup(void)
     ok(res == 0, "WSAStartup() failed unexpectedly: %d\n", res);
 
     /* show that sockets are destroyed automatically after WSACleanup */
-    todo_wine {
     SetLastError(0xdeadbeef);
     res = send(pairs[0].src, "TEST", 4, 0);
     error = WSAGetLastError();
@@ -1258,8 +1257,6 @@ static void test_WithWSAStartup(void)
         }
     }
 
-    }
-
     /* While wine is not fixed, close all sockets manually */
     for (i = 0; i < socks; i++)
     {
From 0f515c8ebe990d34da74d3c2c760ba21d57cfaa9 Mon Sep 17 00:00:00 2001
From: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Date: Mon, 14 Sep 2020 20:23:04 +1000
Subject: [PATCH] ws2_32: Map AI ALL_option in getaddrinfo().

Signed-off-by: Alistair Leslie-Hughes <leslie_alistair@hotmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/socket.c | 1 +
 include/ws2tcpip.h   | 2 ++
 2 files changed, 3 insertions(+)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 246a0e2819b..0ed1af3092a 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -826,6 +826,7 @@ static const int ws_aiflag_map[][2] =
 #ifdef  AI_V4MAPPED
     MAP_OPTION( AI_V4MAPPED ),
 #endif
+    MAP_OPTION( AI_ALL ),
     MAP_OPTION( AI_ADDRCONFIG ),
 };
 
diff --git a/include/ws2tcpip.h b/include/ws2tcpip.h
index 5a444dcb5f3..5ba891185b5 100644
--- a/include/ws2tcpip.h
+++ b/include/ws2tcpip.h
@@ -72,6 +72,7 @@ typedef ADDRINFOA ADDRINFO, *LPADDRINFO;
 # define AI_CANONNAME              0x00000002
 # define AI_NUMERICHOST            0x00000004
 # define AI_NUMERICSERV            0x00000008
+# define AI_ALL                    0x00000100
 # define AI_ADDRCONFIG             0x00000400
 # define AI_V4MAPPED               0x00000800
 # define AI_NON_AUTHORITATIVE      0x00004000
@@ -93,6 +94,7 @@ typedef ADDRINFOA ADDRINFO, *LPADDRINFO;
 # define WS_AI_CANONNAME              0x00000002
 # define WS_AI_NUMERICHOST            0x00000004
 # define WS_AI_NUMERICSERV            0x00000008
+# define WS_AI_ALL                    0x00000100
 # define WS_AI_ADDRCONFIG             0x00000400
 # define WS_AI_V4MAPPED               0x00000800
 # define WS_AI_NON_AUTHORITATIVE      0x00004000
From 98db626566f8d4bcc0de8ad17fe0dabb685d69fe Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Thu, 31 Aug 2017 01:15:05 +0200
Subject: [PATCH] ws2_32: Fix handling of empty string in WS_getaddrinfo.

Fixes a regression introduced in a2053597cc326e2305c44e1c1a954c2e0ee2853e.
---
 dlls/ws2_32/socket.c | 38 ++++++++++++++++++++++++++++++--------
 1 file changed, 30 insertions(+), 8 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 4d2afa946b7..ed1ca2f44b9 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -6673,6 +6673,22 @@ static int convert_eai_u2w(int unixret) {
     return unixret;
 }
 
+static char *get_hostname(void)
+{
+    char *ret;
+    DWORD size = 0;
+
+    GetComputerNameExA( ComputerNamePhysicalDnsHostname, NULL, &size );
+    if (GetLastError() != ERROR_MORE_DATA) return NULL;
+    if (!(ret = HeapAlloc( GetProcessHeap(), 0, size ))) return NULL;
+    if (!GetComputerNameExA( ComputerNamePhysicalDnsHostname, ret, &size ))
+    {
+        HeapFree( GetProcessHeap(), 0, ret );
+        return NULL;
+    }
+    return ret;
+}
+
 static char *get_fqdn(void)
 {
     char *ret;
@@ -6698,9 +6714,8 @@ int WINAPI WS_getaddrinfo(LPCSTR nodename, LPCSTR servname, const struct WS_addr
     struct addrinfo *unixaires = NULL;
     int   result;
     struct addrinfo unixhints, *punixhints = NULL;
-    char *dot, *nodeV6 = NULL, *fqdn;
+    char *nodeV6 = NULL, *hostname, *fqdn;
     const char *node;
-    size_t hostname_len = 0;
 
     *res = NULL;
     if (!nodename && !servname)
@@ -6709,16 +6724,20 @@ int WINAPI WS_getaddrinfo(LPCSTR nodename, LPCSTR servname, const struct WS_addr
         return WSAHOST_NOT_FOUND;
     }
 
+    hostname = get_hostname();
+    if (!hostname) return WSA_NOT_ENOUGH_MEMORY;
+
     fqdn = get_fqdn();
-    if (!fqdn) return WSA_NOT_ENOUGH_MEMORY;
-    dot = strchr(fqdn, '.');
-    if (dot)
-        hostname_len = dot - fqdn;
+    if (!fqdn)
+    {
+        HeapFree(GetProcessHeap(), 0, hostname);
+        return WSA_NOT_ENOUGH_MEMORY;
+    }
 
     if (!nodename)
         node = NULL;
     else if (!nodename[0])
-        node = fqdn;
+        node = hostname;
     else
     {
         node = nodename;
@@ -6733,6 +6752,7 @@ int WINAPI WS_getaddrinfo(LPCSTR nodename, LPCSTR servname, const struct WS_addr
                 nodeV6 = HeapAlloc(GetProcessHeap(), 0, close_bracket - node);
                 if (!nodeV6)
                 {
+                    HeapFree(GetProcessHeap(), 0, hostname);
                     HeapFree(GetProcessHeap(), 0, fqdn);
                     return WSA_NOT_ENOUGH_MEMORY;
                 }
@@ -6762,6 +6782,7 @@ int WINAPI WS_getaddrinfo(LPCSTR nodename, LPCSTR servname, const struct WS_addr
         if (punixhints->ai_socktype < 0)
         {
             SetLastError(WSAESOCKTNOSUPPORT);
+            HeapFree(GetProcessHeap(), 0, hostname);
             HeapFree(GetProcessHeap(), 0, fqdn);
             HeapFree(GetProcessHeap(), 0, nodeV6);
             return SOCKET_ERROR;
@@ -6787,7 +6808,7 @@ int WINAPI WS_getaddrinfo(LPCSTR nodename, LPCSTR servname, const struct WS_addr
     result = getaddrinfo(node, servname, punixhints, &unixaires);
 
     if (result && (!hints || !(hints->ai_flags & WS_AI_NUMERICHOST))
-            && node && (!strcmp(fqdn, node) || (!strncmp(fqdn, node, hostname_len) && !node[hostname_len])))
+            && node && (!strcmp(node, hostname) || !strcmp(node, fqdn)))
     {
         /* If it didn't work it means the host name IP is not in /etc/hosts, try again
         * by sending a NULL host and avoid sending a NULL servname too because that
@@ -6796,6 +6817,7 @@ int WINAPI WS_getaddrinfo(LPCSTR nodename, LPCSTR servname, const struct WS_addr
         result = getaddrinfo(NULL, servname ? servname : "0", punixhints, &unixaires);
     }
     TRACE("%s, %s %p -> %p %d\n", debugstr_a(nodename), debugstr_a(servname), hints, res, result);
+    HeapFree(GetProcessHeap(), 0, hostname);
     HeapFree(GetProcessHeap(), 0, fqdn);
     HeapFree(GetProcessHeap(), 0, nodeV6);
 
-- 
2.27.0
From c29cd38f3c72aee2e02c60945fc5bda1fab4d556 Mon Sep 17 00:00:00 2001
From: "Erich E. Hoover" <erich.e.hoover@wine-staging.com>
Date: Wed, 4 Mar 2015 13:16:20 -0700
Subject: [PATCH] ws2_32: Add support for TF_DISCONNECT to TransmitFile.

---
 dlls/ws2_32/socket.c     | 16 +++++++++++++---
 dlls/ws2_32/tests/sock.c | 11 +++++++++++
 2 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 59dff66e37f..07f812b2391 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -3081,7 +3081,16 @@ static NTSTATUS WS2_transmitfile_base( int fd, struct ws2_transmitfile_async *ws
             return wsaErrStatus();
     }
 
-    return status;
+    if (status != STATUS_SUCCESS)
+        return status;
+
+    if (wsa->flags & TF_DISCONNECT)
+    {
+        /* we can't use WS_closesocket because it modifies the last error */
+        NtClose( SOCKET2HANDLE(wsa->write.hSocket) );
+    }
+
+    return STATUS_SUCCESS;
 }
 
 /***********************************************************************
@@ -3117,6 +3126,7 @@ static BOOL WINAPI WS2_TransmitFile( SOCKET s, HANDLE h, DWORD file_bytes, DWORD
                                      LPOVERLAPPED overlapped, LPTRANSMIT_FILE_BUFFERS buffers,
                                      DWORD flags )
 {
+    DWORD unsupported_flags = flags & ~(TF_DISCONNECT);
     union generic_unix_sockaddr uaddr;
     socklen_t uaddrlen = sizeof(uaddr);
     struct ws2_transmitfile_async *wsa;
@@ -3138,8 +3148,8 @@ static BOOL WINAPI WS2_TransmitFile( SOCKET s, HANDLE h, DWORD file_bytes, DWORD
         WSASetLastError( WSAENOTCONN );
         return FALSE;
     }
-    if (flags)
-        FIXME("Flags are not currently supported (0x%x).\n", flags);
+    if (unsupported_flags)
+        FIXME("Flags are not currently supported (0x%x).\n", unsupported_flags);
 
     if (h && GetFileType( h ) != FILE_TYPE_DISK)
     {
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index 60360bacc21..134bb9625a6 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -9057,6 +9057,17 @@ static void test_TransmitFile(void)
     ok(memcmp(buf, &footer_msg[0], sizeof(footer_msg)) == 0,
        "TransmitFile footer buffer did not match!\n");
 
+    /* Test TransmitFile w/ TF_DISCONNECT */
+    SetFilePointer(file, 0, NULL, FILE_BEGIN);
+    bret = pTransmitFile(client, file, 0, 0, NULL, NULL, TF_DISCONNECT);
+    ok(bret, "TransmitFile failed unexpectedly.\n");
+    compare_file(file, dest, 0);
+    closesocket(client);
+    ok(send(client, "test", 4, 0) == -1, "send() after TF_DISCONNECT succeeded unexpectedly.\n");
+    err = WSAGetLastError();
+    todo_wine ok(err == WSAENOTSOCK, "send() after TF_DISCONNECT triggered unexpected errno (%d != %d)\n",
+                 err, WSAENOTSOCK);
+
     /* Test TransmitFile with a UDP datagram socket */
     closesocket(client);
     client = socket(AF_INET, SOCK_DGRAM, 0);
-- 
2.19.1
From 89a20d7e379e9be6da4230e303b830d190ab1b2c Mon Sep 17 00:00:00 2001
From: "Erich E. Hoover" <erich.e.hoover@gmail.com>
Date: Thu, 16 Jan 2014 19:08:30 -0700
Subject: [PATCH] ws2_32: Add support for TF_REUSE_SOCKET to TransmitFile.

---
 dlls/ws2_32/socket.c     | 13 ++++++++-
 dlls/ws2_32/tests/sock.c |  1 -
 include/winsock.h        |  1 +
 server/protocol.def      |  6 ++++
 server/sock.c            | 63 +++++++++++++++++++++++++++++++++++-----
 5 files changed, 74 insertions(+), 10 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index fed5329b37a..ee449cce581 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -3147,6 +3147,17 @@ static NTSTATUS WS2_transmitfile_base( int fd, struct ws2_transmitfile_async *ws
     if (status != STATUS_SUCCESS)
         return status;
 
+    if (wsa->flags & TF_REUSE_SOCKET)
+    {
+        SERVER_START_REQ( reuse_socket )
+        {
+            req->handle = wine_server_obj_handle( wsa->write.hSocket );
+            status = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        if (status != STATUS_SUCCESS)
+            return status;
+    }
     if (wsa->flags & TF_DISCONNECT)
     {
         /* we can't use WS_closesocket because it modifies the last error */
@@ -3189,7 +3200,7 @@ static BOOL WINAPI WS2_TransmitFile( SOCKET s, HANDLE h, DWORD file_bytes, DWORD
                                      LPOVERLAPPED overlapped, LPTRANSMIT_FILE_BUFFERS buffers,
                                      DWORD flags )
 {
-    DWORD unsupported_flags = flags & ~(TF_DISCONNECT);
+    DWORD unsupported_flags = flags & ~(TF_DISCONNECT|TF_REUSE_SOCKET);
     union generic_unix_sockaddr uaddr;
     socklen_t uaddrlen = sizeof(uaddr);
     struct ws2_transmitfile_async *wsa;
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index 3d338741e0e..492d68e037c 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -8874,7 +8874,6 @@ static void test_TransmitFile(void)
                  err, WSAENOTSOCK);
 
     /* Test TransmitFile with a UDP datagram socket */
-    closesocket(client);
     client = socket(AF_INET, SOCK_DGRAM, 0);
     bret = pTransmitFile(client, NULL, 0, 0, NULL, NULL, 0);
     err = WSAGetLastError();
diff --git a/include/winsock.h b/include/winsock.h
index a8bb35a4c41..42d8f751094 100644
--- a/include/winsock.h
+++ b/include/winsock.h
@@ -835,6 +835,7 @@ typedef struct WS(WSAData)
 
 /* internal per-socket flags */
 #ifdef __WINESRC__
+#define FD_WINE_REUSE              0x08000000
 #define FD_WINE_LISTENING          0x10000000
 #define FD_WINE_NONBLOCKING        0x20000000
 #define FD_WINE_CONNECTED          0x40000000
diff --git a/server/protocol.def b/server/protocol.def
index 92290af701c..77b823caad8 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1410,6 +1410,12 @@ enum server_fd_type
 @END
 
 
+/* Mark a socket to be reused after "closed" */
+@REQ(reuse_socket)
+    obj_handle_t handle;       /* handle to the socket */
+@END
+
+
 /* Set socket event parameters */
 @REQ(set_socket_event)
     obj_handle_t  handle;        /* handle to the socket */
diff --git a/server/sock.c b/server/sock.c
index 1a53ce4b091..03e4ca2eec5 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -86,6 +86,7 @@
 #define FD_CLOSE                   0x00000020
 
 /* internal per-socket flags */
+#define FD_WINE_REUSE              0x08000000
 #define FD_WINE_LISTENING          0x10000000
 #define FD_WINE_NONBLOCKING        0x20000000
 #define FD_WINE_CONNECTED          0x40000000
@@ -132,6 +133,7 @@ static enum server_fd_type sock_get_fd_type( struct fd *fd );
 static int sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async );
 static void sock_queue_async( struct fd *fd, struct async *async, int type, int count );
 static void sock_reselect_async( struct fd *fd, struct async_queue *queue );
+static int sock_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
 
 static int sock_get_ntstatus( int err );
 static unsigned int sock_get_error( int err );
@@ -155,7 +157,7 @@ static const struct object_ops sock_ops =
     NULL,                         /* unlink_name */
     no_open_file,                 /* open_file */
     no_kernel_obj_list,           /* get_kernel_obj_list */
-    fd_close_handle,              /* close_handle */
+    sock_close_handle,            /* close_handle */
     sock_destroy                  /* destroy */
 };
 
@@ -607,6 +609,46 @@ static struct fd *sock_get_fd( struct object *obj )
     return (struct fd *)grab_object( sock->fd );
 }
 
+static int init_sockfd( int family, int type, int protocol )
+{
+    int sockfd;
+
+    sockfd = socket( family, type, protocol );
+    if (sockfd == -1)
+    {
+        if (errno == EINVAL) set_win32_error( WSAESOCKTNOSUPPORT );
+        else set_win32_error( sock_get_error( errno ));
+        return sockfd;
+    }
+    fcntl(sockfd, F_SETFL, O_NONBLOCK); /* make socket nonblocking */
+    return sockfd;
+}
+
+static int sock_close_handle( struct object *obj, struct process *process, obj_handle_t handle )
+{
+    struct sock *sock = (struct sock *)obj;
+
+    assert( obj->ops == &sock_ops );
+    if (!fd_close_handle( obj, process, handle ))
+        return FALSE;
+
+    if (sock->state & FD_WINE_REUSE)
+    {
+        struct fd *fd;
+        int sockfd;
+
+        if ((sockfd = init_sockfd( sock->family, sock->type, sock->proto )) == -1)
+            return TRUE;
+        if (!(fd = create_anonymous_fd( &sock_fd_ops, sockfd, &sock->obj, get_fd_options(sock->fd) )))
+            return TRUE;
+        shutdown( get_unix_fd(sock->fd), SHUT_RDWR );
+        release_object( sock->fd );
+        sock->fd = fd;
+        return FALSE;
+    }
+    return TRUE;
+}
+
 static void sock_destroy( struct object *obj )
 {
     struct sock *sock = (struct sock *)obj;
@@ -660,14 +702,8 @@ static struct object *create_socket( int family, int type, int protocol, unsigne
     struct sock *sock;
     int sockfd;
 
-    sockfd = socket( family, type, protocol );
-    if (sockfd == -1)
-    {
-        if (errno == EINVAL) set_win32_error( WSAESOCKTNOSUPPORT );
-        else set_win32_error( sock_get_error( errno ));
+    if ((sockfd = init_sockfd( family, type, protocol )) == -1)
         return NULL;
-    }
-    fcntl(sockfd, F_SETFL, O_NONBLOCK); /* make socket nonblocking */
     if (!(sock = alloc_object( &sock_ops )))
     {
         close( sockfd );
@@ -1218,6 +1254,17 @@ DECL_HANDLER(accept_into_socket)
     release_object( sock );
 }
 
+/* mark a socket to be recreated on close */
+DECL_HANDLER(reuse_socket)
+{
+    struct sock *sock;
+
+    if (!(sock = (struct sock *)get_handle_obj( current->process, req->handle,
+                                                FILE_WRITE_ATTRIBUTES, &sock_ops))) return;
+    sock->state |= FD_WINE_REUSE;
+    release_object( &sock->obj );
+}
+
 /* set socket event parameters */
 DECL_HANDLER(set_socket_event)
 {
-- 
2.28.0
